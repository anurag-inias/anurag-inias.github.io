# Dijkstra's Algorithm

<style>
.md-logo img {
  content: url('/data-structures/graph/network-light.svg');
}

:root [data-md-color-scheme=slate] .md-logo img  {
  content: url('/data-structures/graph/network-dark.svg');
}
</style>

## About

Dijkstra's algorithm solves the single-source shortest paths problem for directed weighted graph, but requires **all edge weights to be non-negative**.

## Pseudocode

$\ \ \ \ \ \ \ \ \underline{\text{Dijkstra}(G, s)}$ <br>
${\small \ \ 1} \ \ \ \ \ \text{InitializeSingleSource}(s)$ <br>
${\small \ \ 2} \ \ \ \ \ H := \phi \ \ \ \ {\small \text{// empty heap}}$ <br>
${\small \ \ 3} \ \ \ \ \ \textbf{for }\text{each vertex }u \in V\textbf{ do}$ <br>
${\small \ \ 4} \ \ \ \ \ \ \ \ \ \ \ H.\text{offer}(u, u.d) \ \ \ \ {\small \text{// offer }u\text{ to the min-heap with }u.d\text{ as the key}}$ <br>
${\small \ \ 5}$ <br>
${\small \ \ 6} \ \ \ \ \ \textbf{while }H \ne \phi\textbf{ do}$ <br>
${\small \ \ 7} \ \ \ \ \ \ \ \ \ \ \ u = H.\text{poll}()$ <br>
${\small \ \ 8} \ \ \ \ \ \ \ \ \ \ \ \textbf{for }\text{each edge }(u, v) \in E\textbf{ do}$ <br>
${\small \ \ 9} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textbf{if }\text{Relax}(u, v, w_{uv}) = {\small \text{ TRUE }} \textbf{ do}$ <br>
${\small 10} \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ H.\text{update}(v, u.d + w_{uv})$ <br>

## Implementation

=== "Graph"

    ```kotlin linenums="1"
    class Graph(val directed: Boolean = false) {
      // Use a [HashSet] instead to disallow parallel edges out of the box.
      private val adjacency: MutableMap<Int, MutableList<Neighbour>> = HashMap()

      val vertices: List<Int>
        get() = adjacency.keys.stream().toList()

      fun edges(): List<Edge> {
        val list = mutableListOf<Edge>()
        for ((src, neighbours) in adjacency) {
          for (neighbour in neighbours) {
            list.add(Edge(src, neighbour.node, neighbour.weight))
          }
        }
        return list
      }

      fun neighbours(vertex: Int): List<Neighbour> = adjacency[vertex] ?: listOf()

      fun add(vararg vertices: Int) {
        for (v in vertices)
          adjacency.putIfAbsent(v, ArrayList())
      }

      fun connect(src: Int, dst: Int, weight: Int) {
        add(src, dst)
        if (src == dst) return   // disallow self-loops.

        adjacency[src]?.add(Neighbour(dst, weight))
        if (!directed) {
          adjacency[dst]?.add(Neighbour(src, weight)) // Remove this for directed graph.
        }
      }
    }

    data class Edge(val first: Int, val second: Int, val weight: Int)
    data class Neighbour(val node: Int, val weight: Int)
    ```

=== "SingleSourceShortestPaths"

    This class encapsulates the shortest distance and path information generated by the graph algorithm. The $\text{InitializeSingleSource}$ and $\text{Relax}$ methods are located here.

    ```kotlin linenums="1"
    data class SingleSourceShortestPaths(val source: Int, val weights: HashMap<Int, Float>, val predecessors: HashMap<Int, Int>) {
      /**
      * Try to relax edge (u, v). That is, shortest distance estimate of v, v.d is more than the estimate through u.
      *
      * @param u source of edge (u, v).
      * @param v destination of edge (u, v).
      * @return true if edge was related.
      */
      fun relax(u: Int, v: Int, w: Int): Boolean {
        val alt = weights[u]!! + w
        if (alt < weights[v]!!) {
          weights[v] = alt
          predecessors[v] = u
          return true
        }
        return false
      }

      override fun toString(): String {
        return """
          SingleSourceShortestPaths($source) {
            weights: $weights
            predecessors: $predecessors
          }
        """.trimIndent()
      }

      companion object {
        fun initialize(source: Int, graph: Graph): SingleSourceShortestPaths {
          val weights = HashMap<Int, Float>()
          val predecessors = HashMap<Int, Int>()

          for (v in graph.vertices) {
            weights[source] = if (v == source) 0f else Float.POSITIVE_INFINITY
          }

          return SingleSourceShortestPaths(source, weights, predecessors)
        }
      }
    }
    ```

=== "MinHeap"

    We need a min heap implementation which allows updating priority of already inserted elements. The built-in `PriorityQueue` doesn't allow it, so we are writing our own version.

    ```kotlin linenums="1"
    class MinHeap(entries: Set<Map.Entry<Int, Float>>) {

      private val items = Array<Pair<Int, Float>?>(entries.size){ null }
      private var size = 0

      init {
        for (entry in entries) {
          items[size++] = Pair(entry.key, entry.value)
        }
        heapify()
      }

      operator fun get(i: Int): Pair<Int, Float>? = items[i]

      operator fun set(i: Int, pair: Pair<Int, Float>) {
        if (i >= size) throw IndexOutOfBoundsException("Size = $size")

        if (pair.second > this[i]!!.second) {
          items[i] = pair
          sink(i)
        } else if (pair.second < this[i]!!.second) {
          items[i] = pair
          swim(i)
        }
      }

      fun size(): Int = size

      fun poll(): Pair<Int, Float>? {
        if (size < 1) return null
        swap(0, --size)
        sink()

        val last = items[size]
        items[size] = null
        return last
      }

      private fun compare(first: Pair<Int, Float>?, second: Pair<Int, Float>?): Int {
        return first!!.second.compareTo(second!!.second)
      }

      private fun heapify() {
        for (i in size/2 downTo 0) {
          sink(i)
        }
      }

      private fun swim(index: Int = size - 1) {
        var i = index
        while (i > 0) {
          val p = (i - 1) / 2

          if (compare(items[p], items[i]) < 0) break
          swap(i, p)
          i = p
        }
      }

      private fun sink(index: Int = 0) {
        var i = index
        while (i < size) {
          var m = i // index of the minimum element
          val l = 2 * i + 1
          val r = 2 * i + 2

          if (l < size && compare(items[l], items[m]) < 0) m = l
          if (r < size && compare(items[r], items[m]) < 0) m = r

          if (m == i) break
          swap(m, i)
          i = m
        }
      }

      private fun swap(i: Int, j: Int) {
        val t = items[i]
        items[i] = items[j]
        items[j] = t
      }
    }
    ```

=== "Dijkstra's algorithm"

    ```kotlin linenums="1"
    fun Graph.dijkstra(source: Int): SingleSourceShortestPaths {
      val estimates = SingleSourceShortestPaths.initialize(source, graph = this)
      // Add all estimates to a MinHeap.
      val q = MinHeap(estimates.weights.entries)

      while (q.size() > 0) {
        val u = q.poll()!! // Move u to (V - Q) and relax incident edges.
        val neighbours = neighbours(u.first)

        for (i in 0..<q.size()) {
          val v = q[i]!!
          val found = neighbours.find { it.node == v.first }
          if (found == null) continue

          if (estimates.relax(u.first, v.first, found.weight)) {
            q[i] = Pair(v.first, u.second + found.weight)
          }
        }
      }

      return estimates
    }
    ```

## Unit tests

```kotlin linenums="1"
@Test
fun dijkstra_example_1() {
  val graph = Graph(directed = true)

  graph.connect(1, 2, 10)
  graph.connect(1, 4, 5)
  graph.connect(2, 3, 1)
  graph.connect(2, 4, 2)
  graph.connect(3, 5, 4)
  graph.connect(4, 2, 3)
  graph.connect(4, 3, 9)
  graph.connect(4, 5, 2)
  graph.connect(5, 3, 6)
  graph.connect(5, 1, 7)

  assertThat(graph.dijkstra(1).toString()).isEqualTo("""
    SingleSourceShortestPaths(1) {
      weights: {1=0.0, 2=8.0, 3=9.0, 4=5.0, 5=7.0}
      predecessors: {2=4, 3=2, 4=1, 5=4}
    }
  """.trimIndent())
  assertThat(graph.dijkstra(1).toString()).isEqualTo(graph.bellmanFord(1).toString())
}

@Test
fun dijkstra_example_2() {
  val graph = Graph(directed = true)

  graph.connect(1, 2, 1)
  graph.connect(1, 3, 4)
  graph.connect(2, 3, 2)
  graph.connect(2, 4, 6)
  graph.connect(3, 4, 3)

  assertThat(graph.dijkstra(1).toString()).isEqualTo("""
    SingleSourceShortestPaths(1) {
      weights: {1=0.0, 2=1.0, 3=3.0, 4=6.0}
      predecessors: {2=1, 3=2, 4=3}
    }
  """.trimIndent())
  assertThat(graph.dijkstra(1).toString()).isEqualTo(graph.bellmanFord(1).toString())
}
```
