{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, H<sub>2</sub>O </p> <p>nec semper lorem quam in massa.</p>"},{"location":"#code-block","title":"Code block","text":"hello.kt<pre><code>fun main() { \n  println(\"Hello\")\n}\n</code></pre>"},{"location":"#latex","title":"LaTeX","text":"DisplayInline <p>\\[     x = \\frac{y}{z} \\]</p> <p>\\(a \\implies b\\)</p> <p>read more here</p>"},{"location":"#admonitions","title":"Admonitions","text":"<p>with some title</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. </p> and collapsible <p>Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>read more here</p>"},{"location":"#grid","title":"Grid","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. </p> <p>Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p> </p>"},{"location":"graph/about/","title":"About","text":"<p>A graph is a set of vertices \\(V\\) and a set of edges \\(E\\) connecting them.</p>"},{"location":"graph/about/#glossary","title":"Glossary","text":"<ol> <li>A simple graph is one such disallows parallel edges (multigraph) and self-loops.</li> <li>A path is a sequence of adjacent vertices. A simple path is one with distinct vertices and edges. </li> <li>A cycle is a simple path except for the first and last vertices being the same. A tour refers to a cyclic path which coveres every vertex.</li> <li>A subgraph is a subset of a graph's edges and/or vertices.</li> <li>Two graphs are isomorphic if relabelling one's vertices converts it into the other.</li> <li>A graph is connected if every vertex is reachable from every other. Otherwise it's made up of two or more connected components which are connected subgraphs themselves.</li> <li>A graph is complete if there is all vertices are adjacent. A complete subgraph is called a clique.</li> <li>A bipartite graph is one with vertices divided in two sets such that no edge connects vertices of same set.  123456</li> <li>An acyclic connected graph is called a tree. A spanning tree of a connected graph is a subgraph that contains all its vertices and is a tree.</li> <li>Given two vertices, a simple path connecting them that visits every vertex is called Hamilton path, and Euler path if it visits every edge.</li> <li>A directed acyclic graph (DAG) is a digraph with no directed cycles.</li> </ol>"},{"location":"graph/about/#properties","title":"Properties","text":"<ol> <li>A simple graph can edges numbering between \\(V-1\\) and \\(V (V-1) \\, /  \\, 2\\).</li> <li>Total number of different graphs with \\(V\\) vertices is \\(2^{V (V-1) \\, / \\, 2}\\).</li> <li>A graph is considered dense if \\(E \\propto V^2\\), so a graph with \\(O(V \\cdot log \\, V)\\) would be sparse.</li> <li>A graph has an Euler tour iff it is connected and all vertices are of even degree. Or exactly two of its vertices are of odd degree.</li> </ol>"},{"location":"graph/about/#implementation","title":"Implementation","text":"PlainWeighted <pre><code>class Graph {\n  // Use a [HashSet] instead to disallow parallel edges out of the box.\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap()\n\n  val vertices: List&lt;Int&gt;\n    get() = adjacency.keys.stream().toList()\n\n  fun neighbours(vertex: Int): List&lt;Int&gt; = adjacency[vertex] ?: listOf()\n\n  fun add(vararg vertices: Int) {\n    for (v in vertices)\n        adjacency.putIfAbsent(v, ArrayList())\n  }\n\n  fun connect(src: Int, dst: Int) {\n    add(src, dst)\n    if (src == dst) return   // disallow self-loops.\n\n    adjacency[src]?.add(dst)\n    adjacency[dst]?.add(src) // Remove this for directed graph.\n  }\n}\n\n// (Optional) Use a dedicated class to represent vertices.\ndata class Vertex(val label: String) {\n  constructor(label: Int) : this(label.toString())\n  override fun toString() = label\n}\n</code></pre> <pre><code>class Graph {\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Edge&gt;&gt; = HashMap()\n  ...\n}\n\ndata class Edge(val dst: Int, val weight: Int)\n</code></pre>"},{"location":"graph/breadth-first-search/","title":"Breadth-first Search","text":""},{"location":"graph/breadth-first-search/#about","title":"About","text":"<p>BFS explores the vertices of a graph in layers, each layer corresponding to increasing distance from the source. First layer discovers vertices neighbouring to the source, second layer discovers neighbours of the first layer and so on.</p> <p>It has a running time of \\(O(V+E)\\).</p>"},{"location":"graph/breadth-first-search/#implementation","title":"Implementation","text":"Pseudocode<pre><code>Q = stack.push(u)\nmark u as visited\nwhile Q is not empty:\n  v = Q.poll()\n  for each edge (v, w):\n    if w is not visted:\n      mark w as visited\n      Q.push(w)\n</code></pre> Kotlin<pre><code>fun bfs(graph: Graph, source: Vertex) {\n  val visited = HashSet&lt;Vertex&gt;()\n  val queue = ArrayList&lt;Vertex&gt;()\n\n  queue.add(source)\n  visited.add(source)\n\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    print(\"$u \")\n\n    for (v in graph.neighbours(u))\n      if (!visited.contains(v)) {\n        visited.add(v)\n        queue.add(v)\n      }\n  }\n}\n</code></pre> <p>Pay attention to the fact that we mark vertices <code>visited</code> before enqueuing them.</p>"},{"location":"graph/breadth-first-search/#properties","title":"Properties","text":"<ul> <li>BFS gives the shortest path in an unweighted graph, since in an unweighted graph, the shortest path is just the least number of hops.</li> <li>Consequently, it also gives the minimum spanning tree in an unweighted graph. Any spanning tree would be minimum spanning tree in an unweighted graph, so both BFS and DFS would work. </li> </ul>"},{"location":"graph/depth-first-search/","title":"Depth-first Search","text":""},{"location":"graph/depth-first-search/#about","title":"About","text":"<p>DFS is a linear time search and traversal algorithm, i.e. the runtime is \\(O(V+E)\\). In worst case it takes \\(O(V)\\) space to store the stack of vertices.</p>"},{"location":"graph/depth-first-search/#pseudocode","title":"Pseudocode","text":"DFS(u) recursive<pre><code>mark u as visited\nfor each edge (u, v):\n  if v is not visited:\n    DFS(v)\n</code></pre> DFS(u) iterative<pre><code>S = stack.push(u)\nwhile S is not empty:\n  v = S.pop()\n  if v is not visited:\n    mark v as visted\n    for each edge (v, w):\n      S.push(w)\n</code></pre> <p>Notice that in iterative approach, we push vertices on stack regardless of whether they are already visited. Rather, discovered status is checked post <code>pop</code>. </p> <p>If \\(a, b, c\\) are adjacent to \\(u\\), and the recursive DFS visits them in said order, then iterative implementation will visit them in reverse order of \\(c, b, a\\).</p>"},{"location":"graph/depth-first-search/#comparison-to-bfs","title":"Comparison to BFS","text":"BFS(u) iterative<pre><code>Q = stack.push(u)\nmark u as visited\nwhile Q is not empty:\n  v = Q.poll()\n\n\n  for each edge (v, w):\n    if w is not visted:\n      mark w as visited\n      Q.push(w)\n</code></pre> DFS(u) iterative<pre><code>S = stack.push(u)\n\nwhile S is not empty:\n  v = S.pop()\n  if v is not visited:\n    mark v as visted\n    for each edge (v, w):\n      S.push(w)\n</code></pre> <p>Why the iterative DFS postpone checking the <code>visited</code> status of a vertex? Why not check it before pushing it on stack? To understand this, consider the following graph:</p> <p> 0123</p> BFS like check<pre><code>push 1       stack = [1    ] # 1 visited\n\npop 1        stack = [     ]\npush 2 0 3   stack = [2 0 3] # 2 0 3 visited\n\npop 3        stack = [2 0  ]\npop 0        stack = [2    ]\npop 2        stack = [     ]\n\n\nTraversal: 1 3 0 2\n</code></pre> postpone visited check<pre><code>push 1       stack = [1      ]\n\npop 1        stack = [       ] # 1 visited\npush 2 0 3   stack = [2 0 3  ]\n\npop 3        stack = [2 0    ] # 3 visited\npush 2 1     stack = [2 0 2 1] \n\npop 1        stack = [2 0 2  ]\npop 2        stack = [2 0    ] # 2 visited\npush 3 1     stack = [2 0 3 1]\n\npop 1        stack = [2 0 3  ]\npop 3        stack = [2 0    ]\npop 0        stack = [2      ] # 0 visited\npush 1       stack = [2 1    ]\n\npop 1        stack = [2      ]\npop 2        stack = [       ]\n\n\nTraversal: 1 3 2 0\n</code></pre> <p>If we check the <code>visited</code> status before pushing vertices on stack, the algorithm will still work; in the sense that you'd not stuck in loops still. But, it wouldn't be a \"depth first\" search anymore.</p>"},{"location":"graph/depth-first-search/#enhancements","title":"Enhancements","text":"<p>We now consider the following enhancements on this simple version of DFS:</p> <ol> <li>Expand the concept of <code>visited</code>. <ul> <li>Consider a vertex <code>undiscovered</code> (WHITE) when it is not yet visited.</li> <li><code>discovered</code> (GRAY) when it is visted.</li> <li><code>explored</code> (BLACK) when its adjacency list has been examined.</li> </ul> </li> <li>Mark the time when a vertex is discovered as <code>pre</code> and when it's explored as <code>post</code>.</li> <li>If a vertex \\(v\\) is discovered following the edge \\((u, v)\\), mark \\(u\\) as \\(v\\)'s predecessor: \\(v_\\pi=u\\).</li> </ol> DFS(G)<pre><code>for u in G:\n  u.color = WHITE\n  u.\u03c0 = nil\n\ntime = 0\nfor u in G:\n  if u.color == WHITE:\n    DFS(G, u)\n</code></pre> DFS(G, u)<pre><code>u.pre = time++\nu.color = GRAY\n\nfor each (u, v) in G:\n  if v.color == WHITE:\n    v.\u03c0 = u\n    DFS(G, v)\n\nu.post = time++\nu.color = BLACK\n</code></pre> <p>Each <code>DFS(G, u)</code> call yields a depth-first tree \\(G_\\pi\\), a structural description of the traversal. \\(G_\\pi\\) is a subgraph of the original graph \\(G\\).</p> <ul> <li>In an undirected graph \\(G\\), an edge is called tree edge if it's present in \\(G_\\pi\\) too. Otherwise, it's a nontree edge. </li> <li>In a directed graph, you can also have:<ul> <li>Forward edge leading a vertex to its nonchild descendant in \\(G_\\pi\\).</li> <li>Back edge leading a vertex to its ancestor in \\(G_\\pi\\).</li> <li>Cross edge lead to neither descendant nor ancestor. Rather it's a node that's already explored (BLACK).</li> </ul> </li> </ul> <p> abcdforwardbackcross</p>"},{"location":"graph/depth-first-search/#properties","title":"Properties","text":"<p>For any given vertices \\(u\\) and \\(v\\), the ranges \\([u_{pre}, u_{post}]\\) and \\([v_{pre}, v_{post}]\\) either contain each other or are disjoint, but never interweaving. An edge \\((u, v)\\) is: </p> <ul> <li>Tree/Forward edge if \\( \\underset{u}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big]} \\).</li> <li>Back edge if \\( \\underset{v}{\\big[} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big]} \\).</li> <li>Cross edge if \\( \\underset{v}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{u}{\\big]} \\).</li> </ul> <p>Similarly, when a vertex \\(v\\) is first discovered following the edge \\((u, v)\\), then the edge can be distinguished based on \\(v\\)'s color:</p> <ul> <li>Tree edge if <code>v.color = WHITE</code>.</li> <li>Back edge if <code>v.color = GRAY</code>.</li> <li>Forward/Cross edge if <code>v.color = BLACK</code>.</li> </ul>"},{"location":"graph/depth-first-search/#recursive-implementation","title":"Recursive implementation","text":"<pre><code>fun recursive(\n  graph: Graph, source: Int, \n  colorMap: MutableMap&lt;Int, Color&gt; = HashMap(),\n  indent: Int = 0\n) {\n  colorMap[source] = Color.GRAY // vertex discovered\n\n  for (dst in graph.neighbours(source)) {\n    val dstColor = colorMap[dst] ?: Color.WHITE\n    val childIndent = report(source, dst, dstColor, indent) // verbose only\n    if (dstColor == Color.WHITE)\n      recursive(graph, dst, colorMap, childIndent)\n  }\n\n  colorMap[source] = Color.BLACK // vertex explored\n}\n\nprivate fun report(src: Int, dst: Int, dstColor: Color, indent: Int): Int {\n  val type = when (dstColor) {\n    Color.WHITE -&gt; \"tree\"\n    Color.GRAY -&gt; \"back\"\n    else -&gt; \"forward/cross\"\n  }\n  val row = \" \".repeat(indent) + \"$src-$dst\"\n  println(\"$row $type\")\n  return row.length - 1\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <p> 02617345</p> <pre><code>0-2 tree\n  2-0 back\n  2-6 tree\n    6-2 back\n    6-4 tree\n      4-6 back\n      4-5 tree\n        5-4 back\n        5-0 back\n        5-3 tree\n          3-4 back\n          3-5 back\n      4-7 tree\n        7-0 back\n        7-1 tree\n          1-7 back\n        7-4 back\n      4-3 forward/cross\n0-5 forward/cross\n0-7 forward/cross\n</code></pre>"},{"location":"graph/depth-first-search/#iterative-implementation","title":"Iterative implementation","text":"<p>Things are harder in iterative implementation.</p> <pre><code>...\nv.color = GRAY # no-op\n\n\nif v is not visited:\n  mark v as visted\n  for each edge (v, w):\n    S.push(w)\n\n\n\n\nv.color = BLACK # overwrites GRAY\n</code></pre> <pre><code>...\nv.color = GRAY\n\nexplored = true\nif v is not visited:\n  mark v as visted\n  for each edge (v, w):\n    S.push(w)\n    if w is WHITE:\n      explored = false\n\nif explored:\n  v.color = BLACK\n</code></pre> <p>In recursive implementation, vertices adjacent to \\(v\\) will see \\(v\\) as <code>GRAY</code> and thus see \\((v, u)\\) as back edge. But in iterative impelementation, they'd only ever encounter \\(v\\) as <code>BLACK</code> and mistake \\((v, u)\\) as forward/cross edge.</p> <p>To solve this, we mark a vertex <code>BLACK</code> only if the loop prior did not find any undiscovered neighbours.</p> <pre><code>fun iterative(graph: Graph, source: Int) {\n  val color = HashMap&lt;Int, Color&gt;()\n  val stack = ArrayDeque(listOf(Edge(source, source, 0)))\n\n  while (stack.isNotEmpty()) {\n    val (p: Int, u: Int, i: Int) = stack.removeFirst()\n    val c = color[u] ?: Color.WHITE\n    val ci = report(p, u, c, i)\n\n    if (c == Color.WHITE) {\n      color[u] = Color.GRAY\n\n      var explored = true\n      for (v in graph.neighbours(u)) {\n        val vc = color[v] ?: Color.WHITE\n        stack.addFirst(Edge(u, v, ci))\n        if (vc == Color.WHITE) \n          explored = false\n      }\n\n      if (explored)\n        color[u] = Color.BLACK\n    }\n  }\n}\n\ndata class Edge(var pred: Int, var vertex: Int, var indent: Int)\n\nprivate fun report(\n  src: Int, dst: Int, dstColor: Color, indent: Int\n): Int {\n  val type = when (dstColor) {\n    Color.WHITE -&gt; \"tree\"\n    Color.GRAY -&gt; \"back\"\n    else -&gt; \"forward/cross\"\n  }\n  val row = \" \".repeat(indent) + \"$src-$dst\"\n  println(\"$row $type\")\n  return row.length - 1\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <p> 02617345</p> <pre><code>0-0 tree\n  0-7 tree\n    7-4 tree\n      4-3 tree\n        3-5 tree\n          5-3 back\n          5-0 back\n          5-4 back\n        3-4 back\n      4-7 back\n      4-5 forward/cross\n      4-6 tree\n        6-4 back\n        6-2 tree\n          2-6 back\n          2-0 back\n    7-1 tree\n      1-7 back\n    7-0 back\n  0-5 forward/cross\n  0-2 forward/cross\n</code></pre>"},{"location":"graph/topological-sort/","title":"Topological Sort","text":""},{"location":"graph/topological-sort/#example","title":"Example","text":"<p> 12345</p> Valid topological sortings<pre><code>1 2 3 4 5\n1 2 3 5 4\n</code></pre> <p> 134562</p> Valid topological sortings<pre><code>5 6 1 4 2 3\n6 5 4 2 3 1\n</code></pre>"},{"location":"graph/topological-sort/#implementation","title":"Implementation","text":"<p>Due to the recursive nature of the DFS, the <code>post</code> time of a vertex will be ahead of the <code>post</code> time of its predecessor. So all we have to do is run DFS on the graph and sort the vertices in descendending <code>post</code> time.</p> Pseudocode<pre><code>topologicalSort(G):\n  out = []\n  for u in G:\n    if u is not visited:\n      DFS(G, u)\n  return out\n\nDFS(G, u):\n  mark u as visited\n  for each edge (u, v):\n    if v is not visited:\n      DFS(G, v)\n  out = [u, ...out]\n</code></pre> topologicalSort(G)<pre><code>fun topologicalSort(graph: Graph)\n  : List&lt;Vertex&gt; {\n  val out = ArrayList&lt;Vertex&gt;(\n    graph.vertices.size\n  )\n\n  val visited = HashSet&lt;Vertex&gt;()\n  fun dfs(source: Vertex) {\n    visited.add(source)\n    for (n in graph.neighbours(source))\n      if (!visited.contains(n))\n        dfs(n)\n    out.addFirst(source)\n  }\n\n  for (v in graph.vertices)\n    if (!visited.contains(v))\n      dfs(v)\n\n  return out\n}\n</code></pre>"}]}