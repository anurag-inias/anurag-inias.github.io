{"version": "https://jsonfeed.org/version/1", "title": "listless \ud83d\udca4", "home_page_url": "https://listless.dev/", "feed_url": "https://listless.dev/feed_json_updated.json", "description": null, "icon": null, "authors": [], "language": "en", "items": [{"id": "https://listless.dev/data-structures/array/rotation/intro/", "url": "https://listless.dev/data-structures/array/rotation/intro/", "title": "Introduction", "content_html": "<h1>Rotation</h1>\n<p>Rotating an array in either direction sounds like a simple problem, but the challenges show up soon after you start to try and implement it. It's...</p>", "image": null, "date_modified": "2026-01-11T13:54:32.925720+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/array/rotation/", "url": "https://listless.dev/data-structures/array/rotation/", "title": "Rotation", "content_html": "<h1>Rotation</h1>\n<h2>Description</h2>\n<p>Given an array $a$ of $n$ elements, we are asked to move array elements by $k$ steps to the right.</p>\n<h2>Rotation via juggling</h2>\n<h1>...</h1>", "image": null, "date_modified": "2026-01-10T19:05:14+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/algorithms/random/fisher-yates-shuffle/", "url": "https://listless.dev/algorithms/random/fisher-yates-shuffle/", "title": "Fisher-Yates Shuffle", "content_html": "<h1>Fisher-Yates Shuffle</h1>\n<p>Also known as Knuth shuffle algorithm, is an algorithm for shuffling a finite sequence.</p>\n<h2>Pseudocode</h2>\n<p>Consider an array $num$ of $n...</p>", "image": null, "date_modified": "2026-01-04T22:29:52+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/algorithms/random/reservoir-sampling/", "url": "https://listless.dev/algorithms/random/reservoir-sampling/", "title": "Reservoir Sampling", "content_html": "<h1>Reservoir Sampling</h1>\n<p>Reservoir sampling is a family of randomized algorithms for choosing a random sample, of $k$ items from a population of unknown size.</p>\n<p>...</p>", "image": null, "date_modified": "2026-01-04T22:29:52+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/array/fisher-yates-shuffle/", "url": "https://listless.dev/data-structures/array/fisher-yates-shuffle/", "title": "Fisher-Yates Shuffle", "content_html": "<h1>Fisher-Yates Shuffle</h1>\n<p>Also known as Knuth shuffle algorithm, is an algorithm for shuffling a finite sequence.</p>\n<h2>Pseudocode</h2>\n<p>Consider an array $num$ of $n...</p>", "image": null, "date_modified": "2026-01-04T22:29:52+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/array/reservoir-sampling/", "url": "https://listless.dev/data-structures/array/reservoir-sampling/", "title": "Reservoir Sampling", "content_html": "<h1>Reservoir Sampling</h1>\n<p>Reservoir sampling is a family of randomized algorithms for choosing a random sample, of $k$ items from a population of unknown size.</p>\n<p>...</p>", "image": null, "date_modified": "2026-01-04T22:29:52+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/001-pack-two-integers-in-one/", "url": "https://listless.dev/techniques/001-pack-two-integers-in-one/", "title": "Pack two integers in one", "content_html": "<h1>Pack two integers in one</h1>\n<p>Let $a, b \\in [0, n)$. We can pack both $a$ and $b$ in one integer $x$ such that they can be recovered back.</p>\n<p>$$\nx = a + n \\cdot ...</p>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/002-prefix-suffix-arrays/", "url": "https://listless.dev/techniques/002-prefix-suffix-arrays/", "title": "Prefix/Suffix arrays", "content_html": "<h2>Prefix/Suffix arrays</h2>\n<p>This is a powerful technique to efficiently calculate the sum of elements within any subarray while traversing left or right.</p>\n<p>```ko...</p>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/003-converging-pointers/", "url": "https://listless.dev/techniques/003-converging-pointers/", "title": "Converging pointers", "content_html": "<h2>Converging pointers</h2>\n<p>Useful for sorted inputs. Start with pointers, one on each end and start moving them inwards depending on the conditions.</p>\n<h2>Example...</h2>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/004-seen-map/", "url": "https://listless.dev/techniques/004-seen-map/", "title": "Seen map", "content_html": "<h1>Seen map</h1>\n<p>Traverse a list in left-to-right or right-to-left direction while saving the elements seen into a map.</p>\n<p>$$\nseen[a_i] = i\n$$</p>\n<h2>Variant</h2>\n<p>Instead ...</p>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/005-sliding-window/", "url": "https://listless.dev/techniques/005-sliding-window/", "title": "Sliding window", "content_html": "<h1>Sliding window</h1>\n<p>Despite the name, a more apt analogy would be a piece of string.</p>\n<p><img alt=\"\" src=\"005a.svg\">{width=300}</p>\n<p>The key idea is to maintain two pointers $start...</p>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/006-fixed-size-heap/", "url": "https://listless.dev/techniques/006-fixed-size-heap/", "title": "Fixed size heap", "content_html": "<h1>Fixed size Heap</h1>\n<p>It's quite easy to find the smallest and largest element in a list. But what about $k^{th}$ smallest? We can use a max-heap for that.</p>\n<h2>...</h2>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/techniques/007-powerset/", "url": "https://listless.dev/techniques/007-powerset/", "title": "Powerset generation", "content_html": "<h1>Generating powerset</h1>\n<p>Given a set $1, 2, 3, \\dots, n$, we can generate the power set in two ways.</p>\n<h2>Iterative</h2>\n<h2>Iterative approach</h2>\n<p>Each subset is the re...</p>", "image": null, "date_modified": "2026-01-03T16:32:02+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/ubuntu/samba/", "url": "https://listless.dev/ubuntu/samba/", "title": "Samba", "content_html": "<h1>Samba</h1>\n<style>\n.md-logo img {\n  content: url('/ubuntu/ubuntu.svg');\n}\n\n</style>\n\n<h2>Share samba directory</h2>\n<p>=== \"global\"</p>\n<pre><code>```conf\n[global]\n# Ena...\n</code></pre>", "image": null, "date_modified": "2025-11-26T22:55:50+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/numbers/bit-tricks/", "url": "https://listless.dev/data-structures/numbers/bit-tricks/", "title": "Bit tricks", "content_html": "<h1>Bit tricks</h1>\n<style>\n.md-logo img {\n  content: url('/data-structures/numbers/binary-light.svg');\n}\n\n:root [data-md-color-scheme=slate] .md-logo img  {\n  con...", "image": null, "date_modified": "2025-10-24T18:24:29+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/algorithms/maths/gcd/", "url": "https://listless.dev/algorithms/maths/gcd/", "title": "gcd", "content_html": "<h1>GCD</h1>\n<p>Given two non-negative integers $a$ and $b$, their greatest common divisor <strong>GCD</strong> is:</p>\n<p>$$\n\\text{gcd}(a, b) = \\begin{cases}\na, &amp; \\text{ if } b = 0 \\\n...</p>", "image": null, "date_modified": "2025-10-09T23:39:24+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/algorithms/greedy/huffman-coding/", "url": "https://listless.dev/algorithms/greedy/huffman-coding/", "title": "Huffman coding", "content_html": "<h1>Huffman Coding</h1>\n<h2>About</h2>\n<p>Huffman coding is optimal prefix code for lossless data compression. See <a href=\"../../labs/huffman-encoding/index.md\">demo</a>.</p>\n<p>&lt;div mark...</p>", "image": null, "date_modified": "2025-09-20T12:26:55+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/graph/minimum-spanning-tree/kruskal/", "url": "https://listless.dev/data-structures/graph/minimum-spanning-tree/kruskal/", "title": "Kruskal's Algorithm", "content_html": "<h1>Kruskal's algorithm</h1>\n<style>\n.md-logo img {\n  content: url('/data-structures/graph/network-light.svg');\n}\n\n:root [data-md-color-scheme=slate] .md-logo img ...", "image": null, "date_modified": "2025-09-20T12:26:55+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/data-structures/graph/minimum-spanning-tree/prim/", "url": "https://listless.dev/data-structures/graph/minimum-spanning-tree/prim/", "title": "Prim's Algorithm", "content_html": "<h1>Prim's algorithm</h1>\n<style>\n.md-logo img {\n  content: url('/data-structures/graph/network-light.svg');\n}\n\n:root [data-md-color-scheme=slate] .md-logo img  {\n...", "image": null, "date_modified": "2025-09-20T12:26:55+00:00", "authors": [], "tags": null}, {"id": "https://listless.dev/algorithms/practice/", "url": "https://listless.dev/algorithms/practice/", "title": "Practice", "content_html": "<h1>Practice</h1>\n<p><a href=\"#\">:material-notification-clear-all: Clear all</a>{ .md-button }</p>\n<p>|Done |Index   | Title  |Acceptance rate   |Difficulty   |Link  |\n|---|---|---|--...</p>", "image": null, "date_modified": "2025-09-10T18:34:04+00:00", "authors": [], "tags": null}]}