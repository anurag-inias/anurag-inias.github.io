{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"graph/bfs/","title":"Breadth-first Search","text":"<p>BFS is a graph traversal and search algorithm. It explores the vertices of a graph in layers. </p> <ol> <li>First layer contains just the starting vertex \\(s\\).</li> <li>Second layer contains \\(s\\)'s neighbours.</li> <li>Third layer contains these neighbours' neighbours, and so on.</li> </ol> <p> layer-0layer-1layer-2layer-3</p>"},{"location":"graph/bfs/#pseudo-code","title":"Pseudo-code","text":"BFS(G, s)<pre><code>mark s visited\nQ.enqueue(s)\n\nwhile Q is not empty:\n  u = Q.dequeue()\n  print u\n\n  for (u, v) in G:\n    if v is not visited:\n      mark v visited\n      Q.enqueue(v)\n</code></pre>"},{"location":"graph/bfs/#concrete-implementation","title":"Concrete implementation","text":"KotlinUnit tests <pre><code>fun Graph.bfs(): HashMap&lt;Int, Int&gt; {\n  val predecessor = HashMap&lt;Int, Int&gt;()\n  for (s in vertices)\n    if (s !in predecessor)\n      bfs(s, predecessor)\n  return predecessor\n}\n\nfun Graph.bfs(\n  source: Int,\n  pred: HashMap&lt;Int, Int&gt; = HashMap(), // vertex-&gt;predecessor mapping\n): HashMap&lt;Int, Int&gt; {\n  pred[source] = source\n  val queue = ArrayList&lt;Int&gt;().apply { this.add(source) }\n\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    print(\"${pred[u]}-$u \") // do anything here\n\n    for (v in neighbours(u)) {\n      if (v !in pred) {\n        pred[v] = u\n        queue.add(v)\n      }\n    }\n  }\n  return pred\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.assertEquals\nimport org.junit.jupiter.api.Test\n\nclass BreadthFirstSearchKtTest {\n\n  @Test\n  fun nullGraph() {\n    val graph = Graph()\n    graph.add(1, 2, 3, 4, 5)\n    assertEquals(\"{1=1, 2=2, 3=3, 4=4, 5=5}\", graph.bfs().toString())\n  }\n\n  @Test\n  fun triangle() {\n    val graph = Graph()\n    graph.connect(1, 2)\n    graph.connect(2, 3)\n    graph.connect(3, 1)\n    assertEquals(\"{1=1, 2=1, 3=1}\", graph.bfs().toString())\n  }\n\n  @Test\n  fun squareWithOneDiagonal() {\n    val graph = Graph()\n    graph.connect(1, 2)\n    graph.connect(1, 3)\n    graph.connect(2, 3)\n    graph.connect(2, 4)\n    graph.connect(3, 4)\n    graph.connect(3, 5)\n    graph.connect(4, 5)\n    assertEquals(\"{1=1, 2=1, 3=1, 4=2, 5=3}\", graph.bfs().toString())\n  }\n}\n</code></pre>"},{"location":"graph/bfs/#highlights","title":"Highlights","text":"<ul> <li>BFS is similar to iterative DFS but differs in two wasy:<ol> <li>It uses a queue instead of a stack.</li> <li>visited check is done before enqueuing the vertex and as opposed to delaying it to dequeuing time.</li> </ol> </li> <li>It finds the path with least hops (shortest path) in unweighted graphs.</li> <li>It has the running time of \\(O(V+E)\\).</li> </ul>"},{"location":"graph/dfs/","title":"Depth-first Search","text":""},{"location":"graph/dfs/#intro","title":"Intro","text":"<p>It's helpful to consider DFS in contrast to its sibling BFS. Where BFS is the cautious approach, clearing up the graph layer-by-layer, DFS is the head-first adventure in the maze.   BFS is akin to a group of people exploring a maze, splitting off into subgroups at each intersection. Whereas DFS is like a lone explorer uncovering a maze.</p> <p></p>"},{"location":"graph/dfs/#pseudo-code","title":"Pseudo-code","text":""},{"location":"graph/dfs/#basic-version","title":"Basic version","text":"<p> recursive DFS(G, s)<pre><code>mark s visited\nprint u\nfor (s, u) in G:\n  if u is not visited:\n    DFS(G, u)\n</code></pre> iterative DFS(G, s)<pre><code>S.push(s)\nwhile S is not empty:\n  u = S.pop()\n  if u is not visited:\n    mark u visited\n    print u\n    for (u, v) in G:\n      S.push(v)\n</code></pre> <p>Recursive version is DFS at its simplest. Notice that it's not a one-to-one conversion to the iterative version.</p> <p>Iterative DFS is quite like BFS, except:  a) stack instead of queue.  b) vertex is checked for being visited after taking them out of the bag, instead of before being \"bagged\". </p>"},{"location":"graph/dfs/#explanation","title":"Explanation","text":"<p>If we just replace queue with stack in BFS, that'd not be enough for it to be DFS. <code>DFS(G, 2)</code> would spit out <code>2, 3, 1, 4</code>. The strategy of \"carry on\" exploring a path gets disrupted when the next vertex on said path is already marked visited. </p> <p> 1234xDid not \"push onwards\"</p> <p>The right approach then is to postpone marking vertices visited. This gives us the right result <code>2, 3, 4, 1</code>. Let vertices be pushed to the stack multiple times; visit them from the most recently traversed edge.</p> <p> 1234</p> <p>i.e. Give multiple edges: \\(a \\rightarrow t, b \\rightarrow t, c \\rightarrow t\\) leading to the same destination vertex \\(t\\); the incomplete version of DFS (i.e. just BFS with stack) takes the first encountered edge \\(a \\rightarrow t\\) to \\(t\\). The complete solution is to pick the last encountered edge \\(c \\rightarrow t\\).</p>"},{"location":"graph/dfs/#dfs-tree","title":"DFS tree","text":"<p>If we are to trace the above DFS algorithm running on a graph, it'd lead us to a tree structure. Let's call it \\(G_{\\pi}\\). \\(G_{\\pi}\\) will have all the vertices of \\(G\\), meaning it'll be a spanning tree (or forest if there are multiple connected components). However, not all the edges of \\(G\\) will be present in \\(G_{\\pi}\\). We classify edges of \\(G\\) in following manner:</p> <ol> <li>Tree edge: an edge of \\(G\\) that is also present in \\(G_{\\pi}\\). This is an edge DFS actually traversed.</li> <li>Back edge: an edge of \\(G\\) leading a vertex back to its ancestor (proper or parent) in \\(G_{\\pi}\\).</li> <li>Forward edge: an edge of \\(G\\) leading a vertex to its proper descendant in \\(G_{\\pi}\\). </li> <li>Cross edge: all other edges.</li> </ol> <p>An undirected graph can only have #1 and #2, as there are no one-way edges. DFS will traverse would-be forward/cross edges, turning them into tree edges or back edges. </p> <p>From this, identifying a back edge in an undirected graph is straightforward:</p> recursive DFS(G, s)<pre><code>mark s visited\nprint u\nfor (s, u) in G:\n  if u is not visited:\n    DFS(G, u)\n  else:\n    error(\"back edge. loop detected.\")\n</code></pre> iterative DFS(G, s)<pre><code>S.push(s)\nwhile S is not empty:\n  u = S.pop()\n  if u is not visited:\n    mark u visited\n    print u\n    for (u, v) in G:\n      S.push(v)\n  else:\n    error(\"back edge. loop detected.\")\n</code></pre>"},{"location":"graph/dfs/#vertex-coloring","title":"Vertex coloring","text":"<p>Introduce a third state after visited, called explored to mark vertices whose neighbours are all visited. When an edge \\(u \\rightarrow v\\) is first traversed, the color of \\(v\\) determines the type of this edge:</p> <ol> <li><code>WHITE</code> indicates it's a tree edge.</li> <li><code>GRAY</code> indicates it's a back edge.</li> <li><code>BLACK</code> indicates it's a forward or cross edge.</li> </ol> recursivekotliniterativekotlin <pre><code>DFS(G):\n  for u in G:\n    u.color = WHITE\n  for u in G:\n    if u.color is WHITE:\n      DFS(G, u)\n\nDFS(G, u):\n  u.color = GRAY\n  for (u, v) in G:\n    switch(v.color):\n      WHITE: DFS(G, v)\n      GRAY:  # u -&gt; v is back edge\n      BLACK: # u -&gt; v is forward/cross edge\n  u.color = BLACK\n</code></pre> <pre><code>fun Graph.dfs() {\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if ((color[u] ?: Color.WHITE) == Color.WHITE)\n      dfs(u, u, 0, color)\n}\n\nfun Graph.dfs(\n  source: Int,\n  parent: Int = source,\n  indent: Int = 0,\n  color: HashMap&lt;Int, Color&gt; = HashMap()\n) {\n  println(\" \".repeat(indent) + \"$parent-$source tree\")\n  color[source] = Color.GRAY\n\n  val ci = indent + \"$parent-\".length\n  for (n in neighbours(source)) {\n    when(color[n] ?: Color.WHITE) {\n      Color.WHITE -&gt; dfs(n, source, ci, color)\n      Color.GRAY -&gt; println(\" \".repeat(ci) + \"$source-$n back\")\n      Color.BLACK -&gt; println(\" \".repeat(ci) + \"$source-$n forward/cross\")\n    }\n  }\n  color[source] = Color.BLACK\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <pre><code>DFS(G):\n  for u in G:\n    u.color = WHITE\n  for u in G:\n    if u.color is WHITE:\n      DFS(G, u)\n\nDFS(G, s):\n  S.push({\u2205, s, false})\n  while S is not empty:\n    p, u, explored = S.pop()\n    if explored:\n      u.color = BLACK\n      continue\n\n    switch(u.color):\n      WHITE:\n        u.color = GRAY\n        S.push({p, u, true}) # to mark u explored later\n        for (u, v) in G:\n          S.push({u, v})\n      GRAY:  # p -&gt; u is back edge\n      BLACK: # p -&gt; u is forward/cross edge\n</code></pre> <pre><code>fun Graph.dfs() {\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if (color.getOrDefault(u, Color.WHITE) == Color.WHITE)\n      dfs(u, color)\n}\n\nfun Graph.dfs(\n  source: Int,\n  color: HashMap&lt;Int, Color&gt; = HashMap(),\n) {\n  val stack = ArrayDeque&lt;Record&gt;().apply { this.add(Record(source, source)) }\n  while (stack.isNotEmpty()) {\n    val r = stack.removeFirst()\n    val c = color.getOrDefault(r.src, Color.WHITE)\n    if (r.explored) {\n      color[r.src] = Color.BLACK\n      continue\n    }\n    println(\"$r ${c.type}\")\n\n    if (c == Color.WHITE) {\n      color[r.src] = Color.GRAY\n\n      // set up a memo to mark u `BLACK` when all neighbours are explored.\n      stack.addFirst(r.copy(explored = true))\n\n      // push neighbours in reverse order to mimic recusive dfs output.\n      for (v in neighbours(r.src).reversed())\n        stack.addFirst(Record(r.src, v, r.childIndent()))\n    }\n  }\n}\n\ndata class Record(\n  val pred: Int, \n  val src: Int, \n  val indent: Int = 0, \n  val explored: Boolean = false\n) {\n  fun childIndent(): Int = indent + \"$pred-\".length\n  override fun toString(): String {\n    if (explored) return \"$src explored\"\n    return \" \".repeat(indent) + \"$pred-$src\"\n  }\n}\n\nenum class Color(val type: String) {\n  WHITE(\"tree\"), GRAY(\"back\"), BLACK(\"forward/cross\")\n}\n</code></pre> <ol> <li>hello</li> </ol>"},{"location":"graph/dfs/#example-run","title":"Example run","text":"<p> <pre><code>1-1 tree\n  1-2 tree\n    2-1 back\n    2-3 tree\n      3-2 back\n      3-1 back\n      3-4 tree\n        4-2 back\n        4-1 back\n        4-3 back\n    2-4 forward/cross\n  1-3 forward/cross\n  1-4 forward/cross\n</code></pre> <p> 1234</p> <pre><code>0-0 tree\n  0-2 tree\n    2-0 back\n    2-6 tree\n      6-2 back\n      6-4 tree\n        4-6 back\n        4-5 tree\n          5-4 back\n          5-0 back\n          5-3 tree\n            3-4 back\n            3-5 back\n        4-3 forward/cross\n        4-7 tree\n          7-4 back\n          7-1 tree\n            1-7 back\n          7-0 back\n  0-5 forward/cross\n  0-7 forward/cross\n</code></pre> <p> 02543716</p> <pre><code>1-1 tree\n  1-2 tree\n3-3 tree\n4-4 tree\n  4-3 forward/cross\n5-5 tree\n  5-9 tree\n    9-14 tree\n      14-15 tree\n         15-11 tree\n            11-8 tree\n               8-3 forward/cross\n               8-4 forward/cross\n            11-12 tree\n               12-8 forward/cross\n               12-16 tree\n         15-12 forward/cross\n6-6 tree\n  6-2 forward/cross\n  6-7 tree\n    7-3 forward/cross\n    7-11 forward/cross\n  6-12 forward/cross\n10-10 tree\n   10-13 tree\n      13-9 forward/cross\n   10-14 forward/cross\n   10-11 forward/cross\n</code></pre> <p> 12345678910111213141516</p>"},{"location":"graph/dfs/#parenthesis-property","title":"Parenthesis property","text":"<p>Consider any two vertices \\(u\\) and \\(v\\): the ranges \\([u_{s}, u_{f}]\\) and \\([v_{s}, v_{f}]\\) will either contain each other or will be completely disjoint, never partially overlapping. An edge \\(u \\rightarrow v\\) is then: </p> <ol> <li>Tree/forward edge if \\( \\underset{u}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big]} \\).</li> <li>Back edge if \\( \\underset{v}{\\big[} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big]} \\).</li> <li>Cross edge if \\( \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\) or \\( \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\).</li> </ol>"},{"location":"graph/generic-search/","title":"Generic graph search","text":""},{"location":"graph/generic-search/#about","title":"About","text":"<p>The algorithms we explore later are all specialiazation of this generic search algorithm.</p>"},{"location":"graph/generic-search/#pseudo-code","title":"Pseudo-code","text":"GenericSearch(G, s)<pre><code>bag.add(s)\nwhile bag is not empty:\n  u = bag.remove()\n  if u is not visited:\n    mark u visited\n    for (u, v) in G:\n      bag.add(v)\n</code></pre> <p>where bag is a placeholder ADT.</p>"},{"location":"graph/generic-search/#variants","title":"Variants","text":"<ol> <li>Stack: using a stack as \"bag\" gives us DFS. This spits out a depth-first spanning tree, which in general is going to be thin and deep.</li> <li>Queue: this gives us BFS. The spanning tree from this will be wide and shallow.</li> <li>Priority queue: this is basically a family of algorithm on its own.<ul> <li>Edge weights as priority gives an algorithm for discovering Minimum spanning tree, roughly Prim's algorithm.</li> <li>Vertex distance as priority gives shortest-path algorithm in weighted graphs, roughly Dijkstra's algorithm.</li> </ul> </li> </ol>"},{"location":"graph/intro/","title":"Introduction","text":"<p>Formally, a graph \\(G\\) is a set of vertices \\(V\\) and a set of edges \\(E\\) that connect said vertices. We'd be limiting ourselves to simple graphs which disallow duplicate (parallel) edges and edges connecting a vertex to itself (self loop).</p> <p>In an undirected graph, edges are denoted as unordered pair \\(\\{u, v\\}\\) while in a directed graph, they are ordered pair \\((u, v)\\).</p>"},{"location":"graph/intro/#glossary","title":"Glossary","text":"<p>Null/empty graph: there are no edges between the vertices.</p> <p> </p> <p>Connected graph: where there is a path between every given pair of vertices. If graph is undirected then \\(V-1 \\le E \\le {V\\choose2}\\).</p> <p> </p> <p>Complete graph: where an edge exists between every given pair of vertices. There will be exactly \\({V\\choose2} = \\frac{V \\cdot (V-1)}{2}\\) edges  in an undirected complete graph.</p> <p> </p> <p>Planar graph: which can be drawn on a plane such that its edges don't intersect.</p> <p> non-planarplanar</p> <p>Bipartite graph: where vertices can be divided in two sets such that no edge exists between the vertices of same set.</p> <p> </p> <p>Directed acyclic graph: is a directed graph with no cycles.</p> <p> </p> <p>Connected component: is set of vertices in a graph which are reachable from each other. A connected graph thus has a single connected component.</p> <p> </p> <p>Strongly connected component: is the same thing, but in directed graphs.</p> <p> </p> <p>Condensation graph: if each strongly connected component of a graph \\(G\\) is contracted to a single vertex, the resulting graph is called the condensation of \\(G^{SCC}\\), and is a DAG.</p> <p> Gcondensation of G</p> <p>Hamiltonian path: is a path that visits each vertex exactly once. A Hamiltonian cycle/circuit is the same but is a cycle. The problem is NP-complete.</p> <p> </p> <p>Euler walk: same thing but with each edge being used once.</p> <p> 11058749623</p>"},{"location":"graph/intro/#implementation","title":"Implementation","text":"PlainWeighted <pre><code>class Graph {\n  // Use a [HashSet] instead to disallow parallel edges out of the box.\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap()\n\n  val vertices: List&lt;Int&gt;\n    get() = adjacency.keys.stream().toList()\n\n  fun neighbours(vertex: Int): List&lt;Int&gt; = adjacency[vertex] ?: listOf()\n\n  fun add(vararg vertices: Int) {\n    for (v in vertices)\n        adjacency.putIfAbsent(v, ArrayList())\n  }\n\n  fun connect(src: Int, dst: Int) {\n    add(src, dst)\n    if (src == dst) return   // disallow self-loops.\n\n    adjacency[src]?.add(dst)\n    adjacency[dst]?.add(src) // Remove this for directed graph.\n  }\n}\n\n// (Optional) Use a dedicated class to represent vertices.\ndata class Vertex(val label: String) {\n  constructor(label: Int) : this(label.toString())\n  override fun toString() = label\n}\n</code></pre> <pre><code>class Graph {\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Edge&gt;&gt; = HashMap()\n  ...\n}\n\ndata class Edge(val dst: Int, val weight: Int)\n</code></pre>"},{"location":"graph/topological-sort/","title":"Topological Sort","text":""},{"location":"graph/topological-sort/#about","title":"About","text":"<p>Topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every edge \\((u, v)\\), \\(u\\) comes before \\(v\\) in the ordering.</p> <p>Such an ordering is only possible if there are no cycles in the graph, i.e. it's a DAG.</p>"},{"location":"graph/topological-sort/#example","title":"Example","text":"Valid topological sortings<pre><code>1 2 3 4 5\n1 2 3 5 4\n</code></pre> <p> 12345</p> Valid topological sortings<pre><code>5 6 1 4 2 3\n6 5 4 2 3 1\n</code></pre> <p> 156342</p> Valid topological sorting<pre><code>10 13 6 7 5 9 14 15 11 12 16 8 4 3 1 2\n1 5 6 10 2 7 13 9 14 15 11 12 8 16 4 3\n</code></pre> <p> 12345678910111213141516</p>"},{"location":"graph/topological-sort/#dfs-based-algorithm","title":"DFS based algorithm","text":"<p>DFS will finish processing a vertex \\(u\\) before its predecessor \\(p\\), i.e. \\(p_{post} \\gt u_{post}\\). So laying out vertices in the descending order of \\(\\text{post}\\) time will give us their topological ordering. Additionally, if we keep track of each vertex's color, we can also detect cycles (i.e. edge to a <code>GRAY</code> neighbour) and know when topological ordering is not possible.</p> pseudocodekotlin <pre><code>topologicalSort(G):\n  out = []\n  for u in G:\n    if u is not visited:\n      DFS(G, u)\n  return out\n\nDFS(G, u):\n  u.color = GRAY\n\n  for each edge (u, v):\n    if v.color is WHITE:\n      DFS(G, v)\n    else if v.color is GRAY:\n      error \"graph has cycle(s)\"\n\n  u.color = BLACK\n  out = [u, ...out]\n</code></pre> <pre><code>fun Graph.topologicalSort(): List&lt;Int&gt;? {\n  val result = ArrayList&lt;Int&gt;()\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if (color.getOrDefault(u, Color.WHITE) == Color.WHITE)\n      if (!topologicalSort(u, color, result))\n        return null\n  return result\n}\n\nfun Graph.topologicalSort(\n  source: Int,\n  color: HashMap&lt;Int, Color&gt;,\n  result: ArrayList&lt;Int&gt;,\n): Boolean {\n  val stack = ArrayDeque&lt;Record&gt;().apply { this.add(Record(source)) }\n  while (stack.isNotEmpty()) {\n    val (u, explored) = stack.removeFirst()\n    if (explored) {\n      color[u] = Color.BLACK\n      result.addFirst(u)\n      continue\n    }\n\n    when(color[u]) {\n      null, Color.WHITE -&gt; {\n        color[u] = Color.GRAY\n        stack.addFirst(Record(u, true))\n        for (v in neighbours(u))\n          stack.addFirst(Record(v))\n      }\n      Color.GRAY -&gt; return false\n      else -&gt; {}\n    }\n  }\n  return true\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n\ndata class Record(val vertex: Int, val explored: Boolean = false)\n</code></pre>"},{"location":"graph/topological-sort/#kahns-algorithm","title":"Kahn's algorithm","text":"<p>The general idea behind this solution is that topological ordering will place source vertices before sink vertices. So we begin by listing all source vertices first (i.e. \\(\\text{in-degree} = 0\\)), followed by their neighbours, followed by their neighbour's neighbours and so on. </p> pseudocodekotlin <pre><code>result = []\nqueue = list of all source vertices # in-degree = 0\n\nwhile queue is not empty:\n  u = queue.any() # order doesn't matter\n  result.add(u)\n\n  # Derive the new set of \"source\" vertices\n  for (u, v) in G:\n    remove (u, v) from G\n    if --v.indegree is 0:\n      queue.add(v)\n\nif G has edges:\n  error \"graph has cycle(s)\"\nreturn result\n</code></pre> <pre><code>fun Graph.topologicalSort(): List&lt;Int&gt;? {\n  val degree = HashMap&lt;Int, Int&gt;()\n  for (u in vertices) {\n    degree.putIfAbsent(u, 0)\n    for (v in neighbours(u))\n      degree[v] = (degree[v] ?: 0) + 1\n  }\n\n  val result = ArrayList&lt;Int&gt;()\n  val queue = degree.filter { it.value == 0 }.map { it.key }.toCollection(ArrayList())\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    result.add(u)\n\n    for (v in neighbours(u)) {\n      degree[v] = (degree[v] ?: 0) - 1\n      if (degree[v] == 0) queue.add(v)\n    }\n  }\n\n  if (degree.map { it.value }.sum() &gt; 0) return null\n  return result\n}\n</code></pre>"},{"location":"js/object-basics/","title":"Basics","text":"<p>An object is a composite value: an unordered collection of properties, each with a name and a value. Property names are typically strings, but can also be symbols.</p> <p>Object creation comes in two forms: literal and constructed form.</p>"},{"location":"js/object-basics/#object-literal","title":"Object literal","text":"<pre><code>const user = {\n  name: \"Foo\",\n  age: 42\n};\n\nuser.name; // 'Foo'\nuser.age; // 42\n\n// leaves user = { name: 'Foo' }\ndelete user.age; // true\n\nuser['name']; // 'Foo'\n</code></pre> <p>keys can be computed as well:</p> <pre><code>let key = \"umm\";\n\nconst user = {\n  \"foo bar\": 123,\n  [key + ' hey']: 456\n};\n</code></pre> <p>If property name and value are the same, we can use the shorthand notation:</p> <pre><code>const user = {\n  name,  // name: name\n  age,   // age : age\n  patron: 'zeus'\n}\n</code></pre>"},{"location":"js/object-basics/#object-constructor","title":"Object constructor","text":"<p><code>{}</code> syntax is good enough for one-off objects, but how do we create blueprint for a set of objects, all belonging to same \"class\"?</p> <p>For this we use constructor calls. When a function in JS is invoked with <code>new</code> operator, JS hijacks its behaviour so:</p> <pre><code>function User(name) {\n  // this = {};       # implicit\n  this.name = name;\n  greet() {\n    console.log(`hi ${this.name}`);\n  }\n  // return this;     # implicit\n}\n\nconst user = new User(\"foo\"); // { name: 'foo' }\n</code></pre> What about return statement <p>If the function being called has a return statement, it's ignored for primitive return, but not for object.</p> <pre><code>function User(name){ \n  this.name = name; \n  return 5; \n}\n\nnew User('foo'); // User {name: 'foo'}\n</code></pre> <pre><code>function User(name){ \n  this.name = name; \n  return { oink: 'oink' }; \n}\n\nnew User('foo'); // { oink: 'oink }\n</code></pre> <p>There are built-in constructor for object, arrays, dates, and boxed primtives:</p> <pre><code>const o = new Object(); // same as {}.\nconst a = new Array();  // same as [].\n</code></pre>"},{"location":"js/object-basics/#prototypes","title":"Prototypes","text":"<p>Constructor calls do more than just help out with boilerplate. They spit out objects which all point to same prototype. What is that?</p> JS vs. classic OOP <p>In every other OOP language one works with classes which are object blueprints. Objects are instances of classes. A class <code>C</code> which subclasses another <code>P</code> inherits its methods.</p> <p>JS doesn't work this way. For one, there was* no construct for classes, just objects. Secondly, inheritance worked via delegation. Object <code>C</code> would inherit functionality of parent <code>P</code> through a link called prototype. </p> <p>Each object in JS has a built-in property, called its prototype. Prototype itself is an object, which means it itself has its own prototype, making a prototype chain. This chain ends at <code>Object.prototype</code> which has <code>null</code> prototype:</p> <pre><code>const o = {};\n// __proto__ is a legacy feature, is not recommended.\no.__proto__;                             // Object.prototype\nObject.getPrototypeOf(o);                // Object.prototype\nObject.getPrototypeOf(Object.prototype); // null\n\nconst a = [];\nObject.getPrototypeOf(a);                // Array.prototype\nObject.getPrototypeOf(Array.prototype);  // Object.prototype\n</code></pre> <p> []Array.prototypeObject.prototype{}null </p>"},{"location":"js/types/","title":"Types","text":"<p>There are 8 basic types in JS, with all but Objects being primitive.</p>"},{"location":"js/types/#boolean","title":"Boolean","text":"<p>Straightforward (or so I thought), has two possible values: <code>true</code> or <code>false</code>. Following values convert to <code>false</code>:</p> <pre><code>undefined\nnull\n0\n-0\nNaN\n\"\" // empty string\n</code></pre> <p>all other values convert to <code>true</code>. Use <code>===</code>/<code>!==</code> to avoid the implicit type coercion. However, <code>[]</code> is both truthy and loosely <code>false</code>. It's truthy because all objects are truthy, but it's also <code>false</code> because it's converted to primitive via <code>toString()</code> and emits <code>\"\"</code>.</p> <pre><code>if ([]) {\n  // executes\n}\n</code></pre> <pre><code>if ([] == false) {\n  // executes too\n}\n</code></pre> <p>Use <code>Boolean</code> to convert non-boolean values to boolean. Don't use it with <code>new</code> operator as all objects are truthy, even <code>Boolean</code> objects.</p> <pre><code>const good = Boolean(expression);\n\nif (new Boolean(false)) { // Don't do this!\n  // this will execute\n}\n</code></pre>"},{"location":"js/types/#null-undefined","title":"null &amp; undefined","text":"<p>Both indicate the absence of a value. <code>==</code> consider them to be equal, falsy values.</p> <p><code>null</code> is the sole member of its own type and implies a program-level, intentional absence of a value. <code>typeof</code> will report it incorrectly as <code>'object'</code>, that's a legacy bug.</p> <p><code>undefined</code> represents uninitialized values, a deeper kind of a absence. <code>undefined</code> is variable in global scope.</p>"},{"location":"js/types/#symbol","title":"Symbol","text":"<p>Introduced in ES6 to serve as non-string property names. There is no literal syntax for symbols.</p> <p>When you want to keep your symbols private to your own code, guaranteed that they will not conflict with properties used by other code.</p> <p>When you want to share symbol widely with other code.</p> acquire unique symbols<pre><code>const a = Symbol();\nconst b = Symbol(\"foo\");\nconst c = Symbol(\"foo\");\n\na == b; // false\nb == c; // false\n</code></pre> acquire shared symbols<pre><code>const a = Symbol.for(\"shared\");\nconst b = Symbol.for(\"shared\");\n\na === b;          // true\nSymbol.keyFor(a); // \"shared\"\n</code></pre>"},{"location":"js/types/#string","title":"String","text":"<p>JS strings use UTF-16 encoding of Unicode character set as sequences of unsigned 16-bit values. This is fine for most commonly used unicode characters as they'll fit in a single code point. </p> <p>But there are unicode characters which will take two code points. These will report wrong <code>length</code> and attempts to iterate over these may give unexpected results. That's why it's recommended to use for/of loop.</p> wrong way to iterate<pre><code>const smiley = \"\ud83d\ude04\";\nsmiley.length; // 2, \\ud83d\\ude04\n\nfor (let i = 0; i &lt; smiley.length; i++)\n  console.log(smiley.charAt(i)); // \ufffd \ufffd\n</code></pre> right way to iterate<pre><code>const smiley = \"\ud83d\ude04\";\nlet length = 0;\n\nfor (let c of smiley) {\n  console.log(c); // \"\ud83d\ude04\"\n  length++;\n}\n\nconsole.log(length); // 1\n</code></pre> <p>String created from literal and from <code>String()</code> call are primitive values.</p> <p>But ones created from <code>new String()</code> are an object.</p> <pre><code>'test' // 'test'\n\"test\" // 'test'\n\nconst name = \"bob\";\n`hello\n${name}` // 'hello\\nbob', \n\nString(1);        // '1'\ntypeof String(1); // 'string'\n</code></pre> <pre><code>new String(\"foo\"); // String {'foo'}\ntypeof s;          // 'object'\n</code></pre>"},{"location":"js/types/#number-bigint","title":"Number &amp; BigInt","text":"<p>There are no distinct integer and floating representation, instead JS uses 64-bit IEEE 754 floating point for both. \\(1\\) bit for sign, \\(11\\) bits for exponent and \\(52\\) bits for mantissa (a number b/w \\(0\\) and \\(1\\)).</p> <p>\\[   \\text{number} = -1^\\text{sign} \\cdot (1 + \\text{mantissa}) \\cdot 2^{\\text{exponent}} \\]</p> <p>Integers can be represented without loss of precision in range \\([-2^{53}+1, 2^{53}-1]\\). Use <code>BigInt</code> beyond that.</p> <pre><code>Number.MAX_VALUE        // 1.7976931348623157e+308\nNumber.MAX_SAFE_INTEGER // 9007199254740991\nNumber.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 // true, precision loss\n\nconst num = 1234567890123456789012345678901234567890n;\ntypeof num; // bigint\n</code></pre>"},{"location":"js/types/#object","title":"Object","text":"<p>Object types (objects, arrays, functions) need their own section for a thorough breakdown.</p>"},{"location":"js/types/#typeof-heads-up","title":"<code>typeof</code> heads up","text":"<pre><code>typeof 0           // 'number'\ntypeof 1n          // 'bigint'\ntypeof true        // 'boolean'\ntypeof 'foo'       // 'string'\ntypeof undefined   // 'undefined'\ntypeof null        // 'object', known bug \ntypeof Symbol()    // 'symbol'\n\ntypeof {}          // 'object'\ntypeof console.log // 'function', still an object but treated differently by typeof\n</code></pre>"},{"location":"partition/partition/","title":"Partitioning","text":""},{"location":"partition/partition/#two-way-partition","title":"Two-way partition","text":"pseudocodekotlintests <pre><code>parition(nums):\n  cursor = 0, pivot  = nums[0]\n\n  for i in [1, nums.size):\n    if nums[i] &lt; pivot:\n      swap(cursor++, i)\n\n  swap(0, cursor - 1)\n</code></pre> <pre><code>// returns the index of pivot\nfun MutableList&lt;Int&gt;.partitionTwoWay(pivotIndex: Int = 0): Int {\n  if (size &lt; 2) return size-1\n  if (pivotIndex != 0) swap(0, pivotIndex)\n\n  var cursor = 1; val pivot = this[0]\n\n  for (i in 1..&lt;size)\n    if (this[i] &lt; pivot)\n      swap(cursor++, i)\n\n  cursor-- // cursor was left in second half\n  swap(cursor, 0)\n  return cursor\n}\n\nfun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>package partition\n\nimport org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.streams.toList\n\nclass PartitionTest {\n\n  private lateinit var list: MutableList&lt;Int&gt;\n\n  @Test\n  fun testEmpty() {\n    list = mutableListOf()\n    list.partitionTwoWay()\n    assertEquals(listOf&lt;Int&gt;(), list)\n  }\n\n  @Test\n  fun testSingle() {\n    list = mutableListOf(9)\n    list.partitionTwoWay()\n    assertEquals(listOf(9), list)\n  }\n\n  @Test\n  fun testDouble() {\n    list = mutableListOf(1, 2)\n    list.partitionTwoWay()\n    assertEquals(listOf(1, 2), list)\n\n    list = mutableListOf(2, 1)\n    list.partitionTwoWay()\n    assertEquals(listOf(1, 2), list)\n  }\n\n  @Test\n  fun testTriple() {\n    list = mutableListOf(1, 2, 3)\n    list.partitionTwoWay(1)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(1, 3, 2)\n    list.partitionTwoWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 1, 3)\n    list.partitionTwoWay(0)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 3, 1)\n    list.partitionTwoWay(0)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 1, 2)\n    list.partitionTwoWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 2, 1)\n    list.partitionTwoWay(1)\n    assertEquals(listOf(1, 2, 3), list)\n  }\n\n  @Test\n  fun fuzzy() {\n    val nums = ThreadLocalRandom.current().ints(100, 0, 80).toList().toMutableList()\n    val copy = nums.stream().toList().toMutableList().sorted()\n\n    nums.sortByPartition()\n\n    assertEquals(copy, nums)\n  }\n\n  // basically quicksort\n  private fun MutableList&lt;Int&gt;.sortByPartition() {\n    if (size &lt; 2) return\n\n    val pivotIndex = partitionTwoWay()\n\n    val left = this.subList(0, pivotIndex).toMutableList()\n    val right = this.subList(pivotIndex + 1, size).toMutableList()\n\n    left.sortByPartition()\n    right.sortByPartition()\n\n    for (i in 0..&lt;left.size)\n      this[i] = left[i]\n    for (i in 0..&lt;right.size)\n      this[pivotIndex + i + 1] = right[i]\n  }\n}\n</code></pre> <p> ppat the start&lt; p&gt;= pbefore the final swapcursor0 1 ...p&lt; p&gt;= pafter the final swapcursor - 1</p> <p>We start the <code>cursor</code> at index <code>1</code>, moving all the elements \\(\\lt\\) <code>pivot</code> in the first partition.   At the end of the loop, <code>cursor</code> will be left pointing at the start of second partition, which contains elements \\(\\ge\\) <code>pivot</code>.   So we take a step back (<code>cursor--</code>) and move the pivot at the end of the first partition.</p>"},{"location":"partition/partition/#three-way-partition","title":"Three-way partition","text":"pseudocodekotlintests <pre><code>parition(nums, pivot):\n  l = 0, c = 0, r = nums.length - 1\n\n  while c &lt;= r:\n    switch(nums[c]):\n      &lt; pivot -&gt; swap(l++, c++)\n      = pivot -&gt; c++\n      &gt; pivot -&gt; swap(c, r--)\n\n  return (l, c)\n</code></pre> <pre><code>fun MutableList&lt;Int&gt;.partitionThreeWay(pivot: Int = this[0]): Pair&lt;Int, Int&gt; {\n  var l = 0; var c = 0; var r = size - 1\n  while (c &lt;= r)\n    when {\n      this[c] &lt; pivot -&gt; swap(l++, c++)\n      this[c] == pivot -&gt; c++\n      this[c] &gt; pivot -&gt; swap(c, r--)\n    }\n  return Pair(l, c)\n}\n\nfun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.streams.toList\n\nclass PartitionTest {\n\n  @Test\n  fun threeWaySimplest() {\n    var list = mutableListOf(1, 2, 3)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(1, 3, 2)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 1, 3)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 3, 1)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 1, 2)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 2, 1)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n  }\n\n  @Test\n  fun fuzzyThreeWay() {\n    val list = ThreadLocalRandom.current().ints(100, 1, 4).toList().toMutableList()\n    val countOne = list.count { it == 1 }\n    val countTwo = list.count { it == 2 }\n    val countThree = list.count { it == 3 }\n    assertEquals(100, countOne + countTwo + countThree)\n\n    list.partitionThreeWay(2)\n\n    for (i in 0..&lt;countOne)\n      assertEquals(1, list[i])\n    for (i in countOne..&lt;countOne+countTwo)\n      assertEquals(2, list[i])\n    for (i in countOne+countTwo..&lt;countOne+countTwo+countThree)\n      assertEquals(3, list[i])\n  }\n}\n</code></pre> <p> = p&lt; p&gt; p0lc</p> <p>All elements \\(\\lt\\) <code>pivot</code> are in range \\([0, l)\\), elements \\(=\\) <code>pivot</code> are in range \\([l, c)\\),  and all elements \\(\\gt\\) <code>pivot</code> in \\([c, \\text{length})\\).</p>"},{"location":"search/binary/","title":"Binary Search","text":""},{"location":"search/binary/#tldr","title":"tl;dr","text":"<p>Finds an element in a sorted list. If not found, returns the place to insert said element.</p> pseudocodekotlintests <pre><code>search(array, needle):\n  l = 0, r = array.length - 1\n  while l &lt;= r:\n    m = (l + r) / 2\n\n    switch(needle):\n      &lt; array[m] =&gt; r = m - 1\n      = array[m] =&gt; return (m, found)\n      &gt; array[m] =&gt; l = m + 1\n\n  return (l, not found)\n</code></pre> <pre><code>fun &lt;T: Comparable&lt;T&gt;&gt; List&lt;T&gt;.binarySearch(needle: T): Pair&lt;Int, Boolean&gt; {\n  var l = 0; var r = size - 1;\n  while (l &lt;= r) {\n    val m = l + (r - l) / 2 // avoids overflow of (l+r)/2\n    when(needle.compareTo(this[m])) {\n      -1 -&gt; r = m - 1\n       0 -&gt; return Pair(m, true)\n       1 -&gt; l = m + 1\n    }\n  }\n  return Pair(l, false) // l and r have swapped boundary\n}\n</code></pre> <pre><code>package search\n\nimport org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport java.util.stream.IntStream\nimport kotlin.streams.toList\n\nclass BinarySearchTest {\n\n  @Test\n  fun searchEmpty() {\n    assertEquals(Pair(0, false), listOf&lt;Int&gt;().binarySearch(10))\n  }\n\n  @Test\n  fun searchOne() {\n    assertEquals(Pair(0, false), listOf(10).binarySearch(9))\n    assertEquals(Pair(0, true), listOf(10).binarySearch(10))\n    assertEquals(Pair(1, false), listOf(10).binarySearch(11))\n  }\n\n  @Test\n  fun searchTwo() {\n    assertEquals(Pair(0, false), listOf(8, 10).binarySearch(7))\n    assertEquals(Pair(0, true), listOf(8, 10).binarySearch(8))\n    assertEquals(Pair(1, false), listOf(8, 10).binarySearch(9))\n    assertEquals(Pair(1, true), listOf(8, 10).binarySearch(10))\n    assertEquals(Pair(2, false), listOf(8, 10).binarySearch(11))\n  }\n\n  @Test\n  fun fuzzySearchExistingKey() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val existingNeedle = list[ThreadLocalRandom.current().nextInt(100)]\n    val got = list.binarySearch(existingNeedle)\n\n    assertTrue(got.second)\n    assertEquals(existingNeedle, list[got.first])\n  }\n\n  @Test\n  fun fuzzySearchBeyondStart() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedle = list[0] - 1\n    val got = list.binarySearch(nonExistentNeedle)\n\n    assertFalse(got.second)\n    assertEquals(0, got.first)\n  }\n\n  @Test\n  fun fuzzySearchBeyondEnd() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedle = list[list.size - 1] + 1\n    val got = list.binarySearch(nonExistentNeedle)\n\n    assertFalse(got.second)\n    assertEquals(list.size, got.first)\n  }\n\n  @Test\n  fun fuzzySearchMissingInRange() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedles = IntStream.range(0, 80).filter{ list.indexOf(it) &lt; 0 }.filter{ it &gt; list.first() &amp;&amp; it &lt; list.last() }.toList()\n    for (n in nonExistentNeedles) {\n      val got = list.binarySearch(n)\n\n      assertFalse(got.second)\n      assertTrue(list[got.first - 1] &lt; n)\n      assertTrue(n &lt; list[got.first])\n    }\n  }\n}\n</code></pre>"},{"location":"search/binary/#examples","title":"Examples","text":"<pre><code> 0  1  2  3  4  : Index\n[0, 2, 4, 6, 8] : Elements\n\ninsert -1 at 0\nfound   0 at 0\ninsert  1 at 1\nfound   2 at 1\ninsert  3 at 2\nfound   4 at 2\ninsert  5 at 3\nfound   6 at 3\ninsert  7 at 4\nfound   8 at 4\ninsert  9 at 5\ninsert 10 at 5\n</code></pre>"}]}