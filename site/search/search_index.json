{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"graph/bfs/","title":"Breadth-first Search","text":"<p>BFS is a graph traversal and search algorithm. It explores the vertices of a graph in layers. </p> <ol> <li>First layer contains just the starting vertex \\(s\\).</li> <li>Second layer contains \\(s\\)'s neighbours.</li> <li>Third layer contains these neighbours' neighbours, and so on.</li> </ol> <p> layer-0layer-1layer-2layer-3</p>"},{"location":"graph/bfs/#pseudo-code","title":"Pseudo-code","text":"BFS(G, s)<pre><code>mark s visited\nQ.enqueue(s)\n\nwhile Q is not empty:\n  u = Q.dequeue()\n  print u\n\n  for (u, v) in G:\n    if v is not visited:\n      mark v visited\n      Q.enqueue(v)\n</code></pre>"},{"location":"graph/bfs/#concrete-implementation","title":"Concrete implementation","text":"KotlinUnit tests <pre><code>fun Graph.bfs(): HashMap&lt;Int, Int&gt; {\n  val predecessor = HashMap&lt;Int, Int&gt;()\n  for (s in vertices)\n    if (s !in predecessor)\n      bfs(s, predecessor)\n  return predecessor\n}\n\nfun Graph.bfs(\n  source: Int,\n  pred: HashMap&lt;Int, Int&gt; = HashMap(), // vertex-&gt;predecessor mapping\n): HashMap&lt;Int, Int&gt; {\n  pred[source] = source\n  val queue = ArrayList&lt;Int&gt;().apply { this.add(source) }\n\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    print(\"${pred[u]}-$u \") // do anything here\n\n    for (v in neighbours(u)) {\n      if (v !in pred) {\n        pred[v] = u\n        queue.add(v)\n      }\n    }\n  }\n  return pred\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.assertEquals\nimport org.junit.jupiter.api.Test\n\nclass BreadthFirstSearchKtTest {\n\n  @Test\n  fun nullGraph() {\n    val graph = Graph()\n    graph.add(1, 2, 3, 4, 5)\n    assertEquals(\"{1=1, 2=2, 3=3, 4=4, 5=5}\", graph.bfs().toString())\n  }\n\n  @Test\n  fun triangle() {\n    val graph = Graph()\n    graph.connect(1, 2)\n    graph.connect(2, 3)\n    graph.connect(3, 1)\n    assertEquals(\"{1=1, 2=1, 3=1}\", graph.bfs().toString())\n  }\n\n  @Test\n  fun squareWithOneDiagonal() {\n    val graph = Graph()\n    graph.connect(1, 2)\n    graph.connect(1, 3)\n    graph.connect(2, 3)\n    graph.connect(2, 4)\n    graph.connect(3, 4)\n    graph.connect(3, 5)\n    graph.connect(4, 5)\n    assertEquals(\"{1=1, 2=1, 3=1, 4=2, 5=3}\", graph.bfs().toString())\n  }\n}\n</code></pre>"},{"location":"graph/bfs/#highlights","title":"Highlights","text":"<ul> <li>BFS is similar to iterative DFS but differs in two wasy:<ol> <li>It uses a queue instead of a stack.</li> <li>visited check is done before enqueuing the vertex and as opposed to delaying it to dequeuing time.</li> </ol> </li> <li>It finds the path with least hops (shortest path) in unweighted graphs.</li> <li>It has the running time of \\(O(V+E)\\).</li> </ul>"},{"location":"graph/dfs/","title":"Depth-first Search","text":""},{"location":"graph/dfs/#intro","title":"Intro","text":"<p>It's helpful to consider DFS in contrast to its sibling BFS. Where BFS is the cautious approach, clearing up the graph layer-by-layer, DFS is the head-first adventure in the maze.   BFS is akin to a group of people exploring a maze, splitting off into subgroups at each intersection. Whereas DFS is like a lone explorer uncovering a maze.</p> <p></p>"},{"location":"graph/dfs/#pseudo-code","title":"Pseudo-code","text":""},{"location":"graph/dfs/#basic-version","title":"Basic version","text":"<p> recursive DFS(G, s)<pre><code>mark s visited\nprint u\nfor (s, u) in G:\n  if u is not visited:\n    DFS(G, u)\n</code></pre> iterative DFS(G, s)<pre><code>S.push(s)\nwhile S is not empty:\n  u = S.pop()\n  if u is not visited:\n    mark u visited\n    print u\n    for (u, v) in G:\n      S.push(v)\n</code></pre> <p>Recursive version is DFS at its simplest. Notice that it's not a one-to-one conversion to the iterative version.</p> <p>Iterative DFS is quite like BFS, except:  a) stack instead of queue.  b) vertex is checked for being visited after taking them out of the bag, instead of before being \"bagged\". </p>"},{"location":"graph/dfs/#explanation","title":"Explanation","text":"<p>If we just replace queue with stack in BFS, that'd not be enough for it to be DFS. <code>DFS(G, 2)</code> would spit out <code>2, 3, 1, 4</code>. The strategy of \"carry on\" exploring a path gets disrupted when the next vertex on said path is already marked visited. </p> <p> 1234xDid not \"push onwards\"</p> <p>The right approach then is to postpone marking vertices visited. This gives us the right result <code>2, 3, 4, 1</code>. Let vertices be pushed to the stack multiple times; visit them from the most recently traversed edge.</p> <p> 1234</p> <p>i.e. Give multiple edges: \\(a \\rightarrow t, b \\rightarrow t, c \\rightarrow t\\) leading to the same destination vertex \\(t\\); the incomplete version of DFS (i.e. just BFS with stack) takes the first encountered edge \\(a \\rightarrow t\\) to \\(t\\). The complete solution is to pick the last encountered edge \\(c \\rightarrow t\\).</p>"},{"location":"graph/dfs/#dfs-tree","title":"DFS tree","text":"<p>If we are to trace the above DFS algorithm running on a graph, it'd lead us to a tree structure. Let's call it \\(G_{\\pi}\\). \\(G_{\\pi}\\) will have all the vertices of \\(G\\), meaning it'll be a spanning tree (or forest if there are multiple connected components). However, not all the edges of \\(G\\) will be present in \\(G_{\\pi}\\). We classify edges of \\(G\\) in following manner:</p> <ol> <li>Tree edge: an edge of \\(G\\) that is also present in \\(G_{\\pi}\\). This is an edge DFS actually traversed.</li> <li>Back edge: an edge of \\(G\\) leading a vertex back to its ancestor (proper or parent) in \\(G_{\\pi}\\).</li> <li>Forward edge: an edge of \\(G\\) leading a vertex to its proper descendant in \\(G_{\\pi}\\). </li> <li>Cross edge: all other edges.</li> </ol> <p>An undirected graph can only have #1 and #2, as there are no one-way edges. DFS will traverse would-be forward/cross edges, turning them into tree edges or back edges. </p> <p>From this, identifying a back edge in an undirected graph is straightforward:</p> recursive DFS(G, s)<pre><code>mark s visited\nprint u\nfor (s, u) in G:\n  if u is not visited:\n    DFS(G, u)\n  else:\n    error(\"back edge. loop detected.\")\n</code></pre> iterative DFS(G, s)<pre><code>S.push(s)\nwhile S is not empty:\n  u = S.pop()\n  if u is not visited:\n    mark u visited\n    print u\n    for (u, v) in G:\n      S.push(v)\n  else:\n    error(\"back edge. loop detected.\")\n</code></pre>"},{"location":"graph/dfs/#vertex-coloring","title":"Vertex coloring","text":"<p>Introduce a third state after visited, called explored to mark vertices whose neighbours are all visited. When an edge \\(u \\rightarrow v\\) is first traversed, the color of \\(v\\) determines the type of this edge:</p> <ol> <li><code>WHITE</code> indicates it's a tree edge.</li> <li><code>GRAY</code> indicates it's a back edge.</li> <li><code>BLACK</code> indicates it's a forward or cross edge.</li> </ol> recursivekotliniterativekotlin <pre><code>DFS(G):\n  for u in G:\n    u.color = WHITE\n  for u in G:\n    if u.color is WHITE:\n      DFS(G, u)\n\nDFS(G, u):\n  u.color = GRAY\n  for (u, v) in G:\n    switch(v.color):\n      WHITE: DFS(G, v)\n      GRAY:  # u -&gt; v is back edge\n      BLACK: # u -&gt; v is forward/cross edge\n  u.color = BLACK\n</code></pre> <pre><code>fun Graph.dfs() {\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if ((color[u] ?: Color.WHITE) == Color.WHITE)\n      dfs(u, u, 0, color)\n}\n\nfun Graph.dfs(\n  source: Int,\n  parent: Int = source,\n  indent: Int = 0,\n  color: HashMap&lt;Int, Color&gt; = HashMap()\n) {\n  println(\" \".repeat(indent) + \"$parent-$source tree\")\n  color[source] = Color.GRAY\n\n  val ci = indent + \"$parent-\".length\n  for (n in neighbours(source)) {\n    when(color[n] ?: Color.WHITE) {\n      Color.WHITE -&gt; dfs(n, source, ci, color)\n      Color.GRAY -&gt; println(\" \".repeat(ci) + \"$source-$n back\")\n      Color.BLACK -&gt; println(\" \".repeat(ci) + \"$source-$n forward/cross\")\n    }\n  }\n  color[source] = Color.BLACK\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <pre><code>DFS(G):\n  for u in G:\n    u.color = WHITE\n  for u in G:\n    if u.color is WHITE:\n      DFS(G, u)\n\nDFS(G, s):\n  S.push({\u2205, s, false})\n  while S is not empty:\n    p, u, explored = S.pop()\n    if explored:\n      u.color = BLACK\n      continue\n\n    switch(u.color):\n      WHITE:\n        u.color = GRAY\n        S.push({p, u, true}) # to mark u explored later\n        for (u, v) in G:\n          S.push({u, v})\n      GRAY:  # p -&gt; u is back edge\n      BLACK: # p -&gt; u is forward/cross edge\n</code></pre> <pre><code>fun Graph.dfs() {\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if (color.getOrDefault(u, Color.WHITE) == Color.WHITE)\n      dfs(u, color)\n}\n\nfun Graph.dfs(\n  source: Int,\n  color: HashMap&lt;Int, Color&gt; = HashMap(),\n) {\n  val stack = ArrayDeque&lt;Record&gt;().apply { this.add(Record(source, source)) }\n  while (stack.isNotEmpty()) {\n    val r = stack.removeFirst()\n    val c = color.getOrDefault(r.src, Color.WHITE)\n    if (r.explored) {\n      color[r.src] = Color.BLACK\n      continue\n    }\n    println(\"$r ${c.type}\")\n\n    if (c == Color.WHITE) {\n      color[r.src] = Color.GRAY\n\n      // set up a memo to mark u `BLACK` when all neighbours are explored.\n      stack.addFirst(r.copy(explored = true))\n\n      // push neighbours in reverse order to mimic recusive dfs output.\n      for (v in neighbours(r.src).reversed())\n        stack.addFirst(Record(r.src, v, r.childIndent()))\n    }\n  }\n}\n\ndata class Record(\n  val pred: Int, \n  val src: Int, \n  val indent: Int = 0, \n  val explored: Boolean = false\n) {\n  fun childIndent(): Int = indent + \"$pred-\".length\n  override fun toString(): String {\n    if (explored) return \"$src explored\"\n    return \" \".repeat(indent) + \"$pred-$src\"\n  }\n}\n\nenum class Color(val type: String) {\n  WHITE(\"tree\"), GRAY(\"back\"), BLACK(\"forward/cross\")\n}\n</code></pre> <ol> <li>hello</li> </ol>"},{"location":"graph/dfs/#example-run","title":"Example run","text":"<p> <pre><code>1-1 tree\n  1-2 tree\n    2-1 back\n    2-3 tree\n      3-2 back\n      3-1 back\n      3-4 tree\n        4-2 back\n        4-1 back\n        4-3 back\n    2-4 forward/cross\n  1-3 forward/cross\n  1-4 forward/cross\n</code></pre> <p> 1234</p> <pre><code>0-0 tree\n  0-2 tree\n    2-0 back\n    2-6 tree\n      6-2 back\n      6-4 tree\n        4-6 back\n        4-5 tree\n          5-4 back\n          5-0 back\n          5-3 tree\n            3-4 back\n            3-5 back\n        4-3 forward/cross\n        4-7 tree\n          7-4 back\n          7-1 tree\n            1-7 back\n          7-0 back\n  0-5 forward/cross\n  0-7 forward/cross\n</code></pre> <p> 02543716</p> <pre><code>1-1 tree\n  1-2 tree\n3-3 tree\n4-4 tree\n  4-3 forward/cross\n5-5 tree\n  5-9 tree\n    9-14 tree\n      14-15 tree\n         15-11 tree\n            11-8 tree\n               8-3 forward/cross\n               8-4 forward/cross\n            11-12 tree\n               12-8 forward/cross\n               12-16 tree\n         15-12 forward/cross\n6-6 tree\n  6-2 forward/cross\n  6-7 tree\n    7-3 forward/cross\n    7-11 forward/cross\n  6-12 forward/cross\n10-10 tree\n   10-13 tree\n      13-9 forward/cross\n   10-14 forward/cross\n   10-11 forward/cross\n</code></pre> <p> 12345678910111213141516</p>"},{"location":"graph/dfs/#parenthesis-property","title":"Parenthesis property","text":"<p>Consider any two vertices \\(u\\) and \\(v\\): the ranges \\([u_{s}, u_{f}]\\) and \\([v_{s}, v_{f}]\\) will either contain each other or will be completely disjoint, never partially overlapping. An edge \\(u \\rightarrow v\\) is then: </p> <ol> <li>Tree/forward edge if \\( \\underset{u}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big]} \\).</li> <li>Back edge if \\( \\underset{v}{\\big[} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big]} \\).</li> <li>Cross edge if \\( \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\) or \\( \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\).</li> </ol>"},{"location":"graph/generic-search/","title":"Generic graph search","text":""},{"location":"graph/generic-search/#about","title":"About","text":"<p>The algorithms we explore later are all specialiazation of this generic search algorithm.</p>"},{"location":"graph/generic-search/#pseudo-code","title":"Pseudo-code","text":"GenericSearch(G, s)<pre><code>bag.add(s)\nwhile bag is not empty:\n  u = bag.remove()\n  if u is not visited:\n    mark u visited\n    for (u, v) in G:\n      bag.add(v)\n</code></pre> <p>where bag is a placeholder ADT.</p>"},{"location":"graph/generic-search/#variants","title":"Variants","text":"<ol> <li>Stack: using a stack as \"bag\" gives us DFS. This spits out a depth-first spanning tree, which in general is going to be thin and deep.</li> <li>Queue: this gives us BFS. The spanning tree from this will be wide and shallow.</li> <li>Priority queue: this is basically a family of algorithm on its own.<ul> <li>Edge weights as priority gives an algorithm for discovering Minimum spanning tree, roughly Prim's algorithm.</li> <li>Vertex distance as priority gives shortest-path algorithm in weighted graphs, roughly Dijkstra's algorithm.</li> </ul> </li> </ol>"},{"location":"graph/intro/","title":"Introduction","text":"<p>Formally, a graph \\(G\\) is a set of vertices \\(V\\) and a set of edges \\(E\\) that connect said vertices. We'd be limiting ourselves to simple graphs which disallow duplicate (parallel) edges and edges connecting a vertex to itself (self loop).</p> <p>In an undirected graph, edges are denoted as unordered pair \\(\\{u, v\\}\\) while in a directed graph, they are ordered pair \\((u, v)\\).</p>"},{"location":"graph/intro/#glossary","title":"Glossary","text":"<p>Null/empty graph: there are no edges between the vertices.</p> <p> </p> <p>Connected graph: where there is a path between every given pair of vertices. If graph is undirected then \\(V-1 \\le E \\le {V\\choose2}\\).</p> <p> </p> <p>Complete graph: where an edge exists between every given pair of vertices. There will be exactly \\({V\\choose2} = \\frac{V \\cdot (V-1)}{2}\\) edges  in an undirected complete graph.</p> <p> </p> <p>Planar graph: which can be drawn on a plane such that its edges don't intersect.</p> <p> non-planarplanar</p> <p>Bipartite graph: where vertices can be divided in two sets such that no edge exists between the vertices of same set.</p> <p> </p> <p>Directed acyclic graph: is a directed graph with no cycles.</p> <p> </p> <p>Connected component: is set of vertices in a graph which are reachable from each other. A connected graph thus has a single connected component.</p> <p> </p> <p>Strongly connected component: is the same thing, but in directed graphs.</p> <p> </p> <p>Condensation graph: if each strongly connected component of a graph \\(G\\) is contracted to a single vertex, the resulting graph is called the condensation of \\(G^{SCC}\\), and is a DAG.</p> <p> Gcondensation of G</p> <p>Hamiltonian path: is a path that visits each vertex exactly once. A Hamiltonian cycle/circuit is the same but is a cycle. The problem is NP-complete.</p> <p> </p> <p>Euler walk: same thing but with each edge being used once.</p> <p> 11058749623</p>"},{"location":"graph/intro/#implementation","title":"Implementation","text":"PlainWeighted <pre><code>class Graph {\n  // Use a [HashSet] instead to disallow parallel edges out of the box.\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap()\n\n  val vertices: List&lt;Int&gt;\n    get() = adjacency.keys.stream().toList()\n\n  fun neighbours(vertex: Int): List&lt;Int&gt; = adjacency[vertex] ?: listOf()\n\n  fun add(vararg vertices: Int) {\n    for (v in vertices)\n        adjacency.putIfAbsent(v, ArrayList())\n  }\n\n  fun connect(src: Int, dst: Int) {\n    add(src, dst)\n    if (src == dst) return   // disallow self-loops.\n\n    adjacency[src]?.add(dst)\n    adjacency[dst]?.add(src) // Remove this for directed graph.\n  }\n}\n\n// (Optional) Use a dedicated class to represent vertices.\ndata class Vertex(val label: String) {\n  constructor(label: Int) : this(label.toString())\n  override fun toString() = label\n}\n</code></pre> <pre><code>class Graph {\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Edge&gt;&gt; = HashMap()\n  ...\n}\n\ndata class Edge(val dst: Int, val weight: Int)\n</code></pre>"},{"location":"graph/topological-sort/","title":"Topological Sort","text":""},{"location":"graph/topological-sort/#about","title":"About","text":"<p>Topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every edge \\((u, v)\\), \\(u\\) comes before \\(v\\) in the ordering.</p> <p>Such an ordering is only possible if there are no cycles in the graph, i.e. it's a DAG.</p>"},{"location":"graph/topological-sort/#example","title":"Example","text":"Valid topological sortings<pre><code>1 2 3 4 5\n1 2 3 5 4\n</code></pre> <p> 12345</p> Valid topological sortings<pre><code>5 6 1 4 2 3\n6 5 4 2 3 1\n</code></pre> <p> 156342</p> Valid topological sorting<pre><code>10 13 6 7 5 9 14 15 11 12 16 8 4 3 1 2\n1 5 6 10 2 7 13 9 14 15 11 12 8 16 4 3\n</code></pre> <p> 12345678910111213141516</p>"},{"location":"graph/topological-sort/#dfs-based-algorithm","title":"DFS based algorithm","text":"<p>DFS will finish processing a vertex \\(u\\) before its predecessor \\(p\\), i.e. \\(p_{post} \\gt u_{post}\\). So laying out vertices in the descending order of \\(\\text{post}\\) time will give us their topological ordering. Additionally, if we keep track of each vertex's color, we can also detect cycles (i.e. edge to a <code>GRAY</code> neighbour) and know when topological ordering is not possible.</p> pseudocodekotlin <pre><code>topologicalSort(G):\n  out = []\n  for u in G:\n    if u is not visited:\n      DFS(G, u)\n  return out\n\nDFS(G, u):\n  u.color = GRAY\n\n  for each edge (u, v):\n    if v.color is WHITE:\n      DFS(G, v)\n    else if v.color is GRAY:\n      error \"graph has cycle(s)\"\n\n  u.color = BLACK\n  out = [u, ...out]\n</code></pre> <pre><code>fun Graph.topologicalSort(): List&lt;Int&gt;? {\n  val result = ArrayList&lt;Int&gt;()\n  val color = HashMap&lt;Int, Color&gt;()\n  for (u in vertices)\n    if (color.getOrDefault(u, Color.WHITE) == Color.WHITE)\n      if (!topologicalSort(u, color, result))\n        return null\n  return result\n}\n\nfun Graph.topologicalSort(\n  source: Int,\n  color: HashMap&lt;Int, Color&gt;,\n  result: ArrayList&lt;Int&gt;,\n): Boolean {\n  val stack = ArrayDeque&lt;Record&gt;().apply { this.add(Record(source)) }\n  while (stack.isNotEmpty()) {\n    val (u, explored) = stack.removeFirst()\n    if (explored) {\n      color[u] = Color.BLACK\n      result.addFirst(u)\n      continue\n    }\n\n    when(color[u]) {\n      null, Color.WHITE -&gt; {\n        color[u] = Color.GRAY\n        stack.addFirst(Record(u, true))\n        for (v in neighbours(u))\n          stack.addFirst(Record(v))\n      }\n      Color.GRAY -&gt; return false\n      else -&gt; {}\n    }\n  }\n  return true\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n\ndata class Record(val vertex: Int, val explored: Boolean = false)\n</code></pre>"},{"location":"graph/topological-sort/#kahns-algorithm","title":"Kahn's algorithm","text":"<p>The general idea behind this solution is that topological ordering will place source vertices before sink vertices. So we begin by listing all source vertices first (i.e. \\(\\text{in-degree} = 0\\)), followed by their neighbours, followed by their neighbour's neighbours and so on. </p> pseudocodekotlin <pre><code>result = []\nqueue = list of all source vertices # in-degree = 0\n\nwhile queue is not empty:\n  u = queue.any() # order doesn't matter\n  result.add(u)\n\n  # Derive the new set of \"source\" vertices\n  for (u, v) in G:\n    remove (u, v) from G\n    if --v.indegree is 0:\n      queue.add(v)\n\nif G has edges:\n  error \"graph has cycle(s)\"\nreturn result\n</code></pre> <pre><code>fun Graph.topologicalSort(): List&lt;Int&gt;? {\n  val degree = HashMap&lt;Int, Int&gt;()\n  for (u in vertices) {\n    degree.putIfAbsent(u, 0)\n    for (v in neighbours(u))\n      degree[v] = (degree[v] ?: 0) + 1\n  }\n\n  val result = ArrayList&lt;Int&gt;()\n  val queue = degree.filter { it.value == 0 }.map { it.key }.toCollection(ArrayList())\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    result.add(u)\n\n    for (v in neighbours(u)) {\n      degree[v] = (degree[v] ?: 0) - 1\n      if (degree[v] == 0) queue.add(v)\n    }\n  }\n\n  if (degree.map { it.value }.sum() &gt; 0) return null\n  return result\n}\n</code></pre>"},{"location":"js/object-basics/","title":"Basics","text":"<p>An object is a composite value: an unordered collection of properties, each with a name and a value. Property names are typically strings, but can also be symbols.</p> <p>Object creation comes in two forms: literal and constructed form.</p>"},{"location":"js/object-basics/#object-literal","title":"Object literal","text":"<pre><code>const user = {\n  name: \"Foo\",\n  age: 42\n};\n\nuser.name; // 'Foo'\nuser.age; // 42\n\n// leaves user = { name: 'Foo' }\ndelete user.age; // true\n\nuser['name']; // 'Foo'\n</code></pre> <p>keys can be computed as well:</p> <pre><code>let key = \"umm\";\n\nconst user = {\n  \"foo bar\": 123,\n  [key + ' hey']: 456\n};\n</code></pre> <p>If property name and value are the same, we can use the shorthand notation:</p> <pre><code>const user = {\n  name,  // name: name\n  age,   // age : age\n  patron: 'zeus'\n}\n</code></pre>"},{"location":"js/object-basics/#object-constructor","title":"Object constructor","text":"<p><code>{}</code> syntax is good enough for one-off objects, but how do we create blueprint for a set of objects, all belonging to same \"class\"?</p> <p>For this we use constructor calls. When a function in JS is invoked with <code>new</code> operator, JS hijacks its behaviour so:</p> <pre><code>function User(name) {\n  // this = {};       # implicit\n  this.name = name;\n  greet() {\n    console.log(`hi ${this.name}`);\n  }\n  // return this;     # implicit\n}\n\nconst user = new User(\"foo\"); // { name: 'foo' }\n</code></pre> What about return statement <p>If the function being called has a return statement, it's ignored for primitive return, but not for object.</p> <pre><code>function User(name){ \n  this.name = name; \n  return 5; \n}\n\nnew User('foo'); // User {name: 'foo'}\n</code></pre> <pre><code>function User(name){ \n  this.name = name; \n  return { oink: 'oink' }; \n}\n\nnew User('foo'); // { oink: 'oink }\n</code></pre> <p>There are built-in constructor for object, arrays, dates, and boxed primtives:</p> <pre><code>const o = new Object(); // same as {}.\nconst a = new Array();  // same as [].\n</code></pre>"},{"location":"js/object-basics/#prototypes","title":"Prototypes","text":"<p>Constructor calls do more than just help out with boilerplate. They spit out objects which all point to same prototype. What is that?</p> JS vs. classic OOP <p>In every other OOP language one works with classes which are object blueprints. Objects are instances of classes. A class <code>C</code> which subclasses another <code>P</code> inherits its methods.</p> <p>JS doesn't work this way. For one, there was* no construct for classes, just objects. Secondly, inheritance worked via delegation. Object <code>C</code> would inherit functionality of parent <code>P</code> through a link called prototype. </p> <p>Each object in JS has a built-in property, called its prototype. Prototype itself is an object, which means it itself has its own prototype, making a prototype chain. This chain ends at <code>Object.prototype</code> which has <code>null</code> prototype:</p> <pre><code>const o = {};\n// __proto__ is a legacy feature, is not recommended.\no.__proto__;                             // Object.prototype\nObject.getPrototypeOf(o);                // Object.prototype\nObject.getPrototypeOf(Object.prototype); // null\n\nconst a = [];\nObject.getPrototypeOf(a);                // Array.prototype\nObject.getPrototypeOf(Array.prototype);  // Object.prototype\n</code></pre> <p> []Array.prototypeObject.prototype{}null </p>"},{"location":"js/types/","title":"Types","text":"<p>There are 8 basic types in JS, with all but Objects being primitive.</p>"},{"location":"js/types/#boolean","title":"Boolean","text":"<p>Straightforward (or so I thought), has two possible values: <code>true</code> or <code>false</code>. Following values convert to <code>false</code>:</p> <pre><code>undefined\nnull\n0\n-0\nNaN\n\"\" // empty string\n</code></pre> <p>all other values convert to <code>true</code>. Use <code>===</code>/<code>!==</code> to avoid the implicit type coercion. However, <code>[]</code> is both truthy and loosely <code>false</code>. It's truthy because all objects are truthy, but it's also <code>false</code> because it's converted to primitive via <code>toString()</code> and emits <code>\"\"</code>.</p> <pre><code>if ([]) {\n  // executes\n}\n</code></pre> <pre><code>if ([] == false) {\n  // executes too\n}\n</code></pre> <p>Use <code>Boolean</code> to convert non-boolean values to boolean. Don't use it with <code>new</code> operator as all objects are truthy, even <code>Boolean</code> objects.</p> <pre><code>const good = Boolean(expression);\n\nif (new Boolean(false)) { // Don't do this!\n  // this will execute\n}\n</code></pre>"},{"location":"js/types/#null-undefined","title":"null &amp; undefined","text":"<p>Both indicate the absence of a value. <code>==</code> consider them to be equal, falsy values.</p> <p><code>null</code> is the sole member of its own type and implies a program-level, intentional absence of a value. <code>typeof</code> will report it incorrectly as <code>'object'</code>, that's a legacy bug.</p> <p><code>undefined</code> represents uninitialized values, a deeper kind of a absence. <code>undefined</code> is variable in global scope.</p>"},{"location":"js/types/#symbol","title":"Symbol","text":"<p>Introduced in ES6 to serve as non-string property names. There is no literal syntax for symbols.</p> <p>When you want to keep your symbols private to your own code, guaranteed that they will not conflict with properties used by other code.</p> <p>When you want to share symbol widely with other code.</p> acquire unique symbols<pre><code>const a = Symbol();\nconst b = Symbol(\"foo\");\nconst c = Symbol(\"foo\");\n\na == b; // false\nb == c; // false\n</code></pre> acquire shared symbols<pre><code>const a = Symbol.for(\"shared\");\nconst b = Symbol.for(\"shared\");\n\na === b;          // true\nSymbol.keyFor(a); // \"shared\"\n</code></pre>"},{"location":"js/types/#string","title":"String","text":"<p>JS strings use UTF-16 encoding of Unicode character set as sequences of unsigned 16-bit values. This is fine for most commonly used unicode characters as they'll fit in a single code point. </p> <p>But there are unicode characters which will take two code points. These will report wrong <code>length</code> and attempts to iterate over these may give unexpected results. That's why it's recommended to use for/of loop.</p> wrong way to iterate<pre><code>const smiley = \"\ud83d\ude04\";\nsmiley.length; // 2, \\ud83d\\ude04\n\nfor (let i = 0; i &lt; smiley.length; i++)\n  console.log(smiley.charAt(i)); // \ufffd \ufffd\n</code></pre> right way to iterate<pre><code>const smiley = \"\ud83d\ude04\";\nlet length = 0;\n\nfor (let c of smiley) {\n  console.log(c); // \"\ud83d\ude04\"\n  length++;\n}\n\nconsole.log(length); // 1\n</code></pre> <p>String created from literal and from <code>String()</code> call are primitive values.</p> <p>But ones created from <code>new String()</code> are an object.</p> <pre><code>'test' // 'test'\n\"test\" // 'test'\n\nconst name = \"bob\";\n`hello\n${name}` // 'hello\\nbob', \n\nString(1);        // '1'\ntypeof String(1); // 'string'\n</code></pre> <pre><code>new String(\"foo\"); // String {'foo'}\ntypeof s;          // 'object'\n</code></pre>"},{"location":"js/types/#number-bigint","title":"Number &amp; BigInt","text":"<p>There are no distinct integer and floating representation, instead JS uses 64-bit IEEE 754 floating point for both. \\(1\\) bit for sign, \\(11\\) bits for exponent and \\(52\\) bits for mantissa (a number b/w \\(0\\) and \\(1\\)).</p> <p>\\[   \\text{number} = -1^\\text{sign} \\cdot (1 + \\text{mantissa}) \\cdot 2^{\\text{exponent}} \\]</p> <p>Integers can be represented without loss of precision in range \\([-2^{53}+1, 2^{53}-1]\\). Use <code>BigInt</code> beyond that.</p> <pre><code>Number.MAX_VALUE        // 1.7976931348623157e+308\nNumber.MAX_SAFE_INTEGER // 9007199254740991\nNumber.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 // true, precision loss\n\nconst num = 1234567890123456789012345678901234567890n;\ntypeof num; // bigint\n</code></pre>"},{"location":"js/types/#object","title":"Object","text":"<p>Object types (objects, arrays, functions) need their own section for a thorough breakdown.</p>"},{"location":"js/types/#typeof-heads-up","title":"<code>typeof</code> heads up","text":"<pre><code>typeof 0           // 'number'\ntypeof 1n          // 'bigint'\ntypeof true        // 'boolean'\ntypeof 'foo'       // 'string'\ntypeof undefined   // 'undefined'\ntypeof null        // 'object', known bug \ntypeof Symbol()    // 'symbol'\n\ntypeof {}          // 'object'\ntypeof console.log // 'function', still an object but treated differently by typeof\n</code></pre>"},{"location":"kt/coroutines/","title":"Coroutines","text":""},{"location":"kt/coroutines/#intro","title":"Intro","text":"<p>source and Kotlin in Action 2</p> <p>A coroutine is an instance of suspendable computation. Conceptually similar to a thread, but with a number of advantages:</p> <ol> <li>Unlike threads, cheap to make. One can run 100K or more coroutines on a bog standard laptop.</li> <li>Unlike threads, doesn't block system resources when suspended.</li> <li>Structured concurrency ensures that child coroutines don't hang around when parent coroutine is cancelled.</li> </ol> <p>Under the hood, coroutines are implemented by running on one or more JVM threads. Over its life, a coroutine may start on one thread, suspend, and then resume on another.</p> <pre><code>fun main() = runBlocking {\n  launch {\n    delay(1000L)\n    println(\"World!\")\n  }\n  print(\"hello \")\n}\n</code></pre> <p>this prints <code>Hello World!</code>. Let's break it down:</p> <ol> <li> <p><code>runBlocking</code> is a coroutine builder, a special one at that which bridges the regular blocking code with suspending functions. Without it, <code>launch</code> line will give the error <code>Unresolved reference: launch</code>. It's called <code>runBlocking</code> because the thread that runs it (i.e. main thread here) gets blocked for the duration of the call.</p> </li> <li> <p><code>launch</code> is another coroutine builder that launches a new coroutine concurrently with the rest of the code. That's why <code>Hello</code> gets printed first.</p> </li> <li> <p><code>delay</code> is a special suspending function that suspends the coroutine for the specified time. Unlike <code>Thread.sleep</code>, this does not block the underlying thread, and instead allows other coroutine to take turn.</p> </li> <li> <p>A suspending function can only be called from another suspending function or a coroutine.</p> </li> <li> <p><code>launch</code> is meant for starting coroutines that don't return value. Actually, <code>launch</code> returns a <code>Job</code>, think of a <code>ListenableFuture&lt;Void&gt;</code>.</p> </li> <li> <p>If you want a result from a coroutine, start it with <code>async</code> which returns a <code>Deferred&lt;T&gt;</code>.</p> </li> </ol> <p>Another example:</p> <pre><code>fun main() = runBlocking {\n  println(\"parent starts\")                 // 1\n\n  launch {\n    println(\"second coroutine\")            // 3\n    delay(100.milliseconds)\n    println(\"second coroutine resumed\")    // 5\n  }\n\n  launch {\n    println(\"third coroutine\")             // 4\n  }\n\n  println(\"parent launched 2 coroutines\")  // 2\n}\n</code></pre> <pre><code>parent starts\nparent launched 2 coroutines\nsecond coroutine\nthird coroutine\nsecond coroutine resumed\n</code></pre>"},{"location":"kt/coroutines/#dispatchers","title":"Dispatchers","text":"<pre><code>launch(Dispatchers.Default) {\n  // do something on default dispatcher\n}\n</code></pre> <p>Dispatcher determines what thread(s) the coroutine uses for its execution. Dispatchers are inherited by child corountines from their parents. Following dispatchers are available out of the box:</p> Dispatcher Number of threads Used for <code>Dispatchers.Default</code> Number of CPU cores General purpose CPU-bound <code>Dispatchers.Main</code> One UI work <code>Dispatchers.IO</code> Auto-scaling  \\(\\text{max}(\\text{CPU cores}, 64)\\) Blocking IO task <code>Dispatchers.Unconfined</code> Any Used for immediate scheduling <code>limitedParallelism(n)</code> <code>n</code> Custom scenarios <ul> <li><code>Unconfined</code> executes coroutine immediately on current thread and later resumes it whatever thread called <code>resume</code>.</li> <li><code>limitedParallelism(n)</code> creates a view of the current dispatcher but with guarantee that no more than <code>n</code> coroutines are executed at any time.</li> </ul>"},{"location":"kt/coroutines/#launch-and-async","title":"<code>launch</code> and <code>async</code>","text":"<pre><code>public fun CoroutineScope.launch(\n  context: CoroutineContext = EmptyCoroutineContext,\n  ...\n): Job { ... }\n</code></pre> <pre><code>public fun &lt;T&gt; CoroutineScope.async(\n  context: CoroutineContext = EmptyCoroutineContext,\n  ...\n): Deferred&lt;T&gt; { ... }\n</code></pre> <p>Both coroutine builders are actually extension of <code>CoroutineScope</code>. Well, what is a <code>CoroutineScope</code>?</p>"},{"location":"kt/coroutines/#coroutinescope","title":"CoroutineScope","text":"<pre><code>public interface CoroutineScope {\n  public val coroutineContext: CoroutineContext\n}\n</code></pre> <p>It's just a wrapper arount <code>CoroutineContext</code>. And what is that?</p>"},{"location":"kt/coroutines/#coroutinecontext","title":"CoroutineContext","text":"<pre><code>// Persistent context for the coroutine. It is an indexed set of [Element] instances.\npublic interface CoroutineContext {\n  public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E?\n}\n\n...\n\npublic interface Element : CoroutineContext {\n  public val key: Key&lt;*&gt;\n  ...\n}\n</code></pre> <p>It's an indexed set of <code>Element</code>s, each of which are <code>CoroutineContext</code> themselves, exemplified in following snippet:</p> <pre><code>fun main() {\n  val foo: CoroutineContext = CoroutineName(\"foo\")\n  println(foo[CoroutineName]) // CoroutineName(foo)\n  println(foo[Job]) // null\n\n  val bar: CoroutineContext = CoroutineName(\"bar\")\n  println(bar[CoroutineName]) // CoroutineName(bar)\n  println(foo[Job]) // null\n\n  println((foo + bar)[CoroutineName]) // CoroutineName(bar)\n  println((bar + foo)[CoroutineName]) // CoroutineName(foo)\n}\n</code></pre> <p>P.S. <code>EmptyCoroutineContext</code> seen before has no elements, as the name implies.  </p> <p>That is, coroutine context is a set of \"elements\". The main elements are <code>Job</code> and the dispatcher.</p> <pre><code>fun main() {\n  val foo: CoroutineContext = Dispatchers.Default + Job()\n  println(foo[CoroutineName]) // null\n  println(foo[Job]) // JobImpl{Active}@5c29bfd\n  println(foo[Job]?.isActive) // true\n\n  foo.job.cancel()\n\n  println(foo[Job]?.isActive) // false\n}\n</code></pre>"},{"location":"kt/coroutines/#adding-it-all-together","title":"Adding it all together","text":"<p>Source - Roman Elizarov: Kotlin Project Lead</p> <p>Recall our prior example of launching a coroutine with a given dispatcher:</p> <pre><code>fun main() = runBlocking {\n  launch(Dispatchers.IO + Job()) {  // Passed context = [IO + Job()]\n  }\n}\n</code></pre> <p><code>launch</code>/<code>async</code> is passed a <code>CoroutineContext</code> as parameter. But it also is an extension of <code>CoroutineScope</code> which itself is wrapping a context. That is, a coroutine builder is actually taking in two contexts.</p> <p>The two contexts are merged, with elements of passed in context taking precedence over the elements of implicit (scoped) context. This is the parent context of the new coroutine. The child context is this <code>parent context</code> \\(+\\) a new <code>Job()</code> (child of parent job).</p> <p> Scope JobScope ContextScope dispatcherParent ScopePassed JobPassed ContextPassed dispatcher.launch()+Parent JobParent ContextParent dispatcher= Scope Job Passed Job= Parent dispatcher Passed dispatcherChild Job = Job()Child ContextParent DispatcherChild ScopePassed context overwrites elementschild context = parent context + Job()</p> <p>We can see it all in work like this:</p> <pre><code>fun main() = runBlocking {\n  launch(Dispatchers.Default) {\n    val scopeContext = currentCoroutineContext()      // [StandaloneCoroutine{Active}@7d6b54ea, Dispatchers.Default]\n    val scopeJob = scopeContext.job                   //  StandaloneCoroutine{Active}@7d6b54ea\n\n    val parentContext = scopeContext + Dispatchers.IO // [StandaloneCoroutine{Active}@7d6b54ea, Dispatchers.IO]\n\n    launch(Dispatchers.IO) {\n      val childContext = currentCoroutineContext()    // [StandaloneCoroutine{Active}@4bcf3652, Dispatchers.IO]\n      val childJob = childContext.job                 //  StandaloneCoroutine{Active}@4bcf3652\n\n      println(\"${childContext == parentContext + childJob}\") // true\n      println(\"${childJob.parent == scopeJob}\")              // true \n    }\n  }\n}\n</code></pre> <p>Had we passing in <code>Dispatcher.IO + Job()</code> to <code>launch</code>, the <code>childJob</code> would have been child of this new <code>Job</code> instead.</p>"},{"location":"kt/coroutines/#coroutinescope_1","title":"<code>coroutineScope</code>","text":"<p>Source</p> <p>In addition to coroutine scope provided by different builders, it is possible to create your own scope using <code>coroutineScope</code>. It creates a new scope and does not complete until all launched children complete.</p> <p>It looks similar to <code>runBlocking</code>, but <code>runBlocking</code> blocks current thread while <code>coroutineScope</code> just suspends. That's why <code>corountineScope</code> is a suspend function whereas <code>runBlocking</code> is a regular function.</p> <p><code>coroutineScope</code> will fail if any of the child coroutine fail, resulting in cancellation of all other children. If you want other children to still complete regardless, use <code>supervisorScope</code>.</p> <pre><code>fun main() = runBlocking {\n  coroutineScope {\n    launch {\n      delay(5000L)\n      println(\"a\")\n    }\n    launch {\n      delay(1L)\n      throw Exception()\n    }\n  }\n  println()\n}\n</code></pre> <pre><code>fun main() = runBlocking {\n  supervisorScope {\n    launch {\n      delay(5000L)\n      println(\"a\")\n    }\n    launch {\n      delay(1L)\n      throw Exception()\n    }\n  }\n  println()\n}\n</code></pre> <p>finishes in right away</p> <p>finishes after 5 second </p>"},{"location":"kt/coroutines/#cancelling-coroutines","title":"Cancelling coroutines","text":"<p>Kotlin in Action 2</p> <p>We can call <code>cancel</code> on both <code>Job</code> and <code>Deferred&lt;T&gt;</code> to cancel the coroutine ahead of its time. This is useful in avoiding unnecessary work and leaks. </p> <p>Cancellation of parent cadcades through all children coroutines. Note that this is different thing from <code>coroutineScope/supervisorScope</code> which is about sibling cancellation.</p> <pre><code>fun main() = runBlocking {\n  val job = launch {\n    launch {\n      launch {\n        launch {\n          delay(1000L)\n          println(\"descendant 1 done\") // prints\n        }\n        launch {\n          delay(10_000L)\n          println(\"descendant 2 done\") // does not print\n        }\n      }\n    }\n  }\n  delay(1500L)\n  job.cancel()\n}\n</code></pre> <p>this exits right after 1.5s.</p> <p>We can also use <code>withTimeout</code> and <code>withTimeoutOrNull</code> to automatically cancel a coroutine.</p> <pre><code>fun main() = runBlocking {\n  withTimeout(50_000L) {\n    delay(10_000L)\n    println(\"hello\")\n  }\n}\n</code></pre> <pre><code>fun main() = runBlocking {\n  withTimeout(500L) {\n    delay(10_000L)\n    println(\"hello\")\n  }\n}\n</code></pre> <p>prints <code>hello</code> after 10s</p> <p>aborts after .5s</p> <p>Cancellation is implemented by throwing a special exception type <code>CancellationException</code>. So never do a catch-all for <code>CancellationException</code> or its super-type <code>IllegalStateException</code>, <code>RuntimeException</code>, <code>Exception</code> and <code>Throwable</code>. Otherwise you will prevent the cancellation.</p>"},{"location":"kt/coroutines/#suspension-point","title":"Suspension Point","text":"<p>source 1 and 2.</p> <p>A suspending function is different from non-suspending functions by having zero or more suspension points - statements in the body where the function execution can be paused and resumed later. Usually that's the points at which the function calls other suspending functions. </p> <p>That's why non-suspending functions cannot call suspending ones, as they do not support suspension points. Also, suspending functions may call non-suspending functions knowing that it will not introduce a suspension point. See function coloring.</p> <pre><code>coroutineScope {\n  print(\"A\")\n  delay(500L) &lt;- suspension point\n  print(\"B\")\n  print(\"C\")\n}\n</code></pre> <p>this code will either print <code>A</code> or <code>ABC</code>, but never <code>AB</code> as there are no suspension point between <code>B</code> and <code>C</code>. </p> <p>Why are we talking about this? Consider the following example:</p> <pre><code>fun heavyCpuWork(): Int {\n  while(...) {\n    compute()\n  }\n}\n\nfun main() = runBlocking {\n  launch { heavyCpuWork() }\n  launch { heavyCpuWork() }\n}\n</code></pre> <p>Just using coroutines will not magically make our code concurrent. In the example above, <code>heavyCpuWork</code> has no suspension point. As a result, even when running on a coroutine, it will never suspend to let other coroutine have a go. The first corountine will finish to completion before second one gets a chance.</p> <pre><code>fun heavyCpuWork(): Int {\n  while(...) {\n    compute()\n    yield()\n  }\n}\n</code></pre> <pre><code>fun heavyCpuWork(): Int {\n  while(...) {\n    if (isActive) {\n      compute()\n    }\n  }\n}\n</code></pre> <p>Use <code>yield</code> function lets coroutine voluntarily give way for other corountines.</p> <p>The other approach is to explicitly check cancellation status.</p>"},{"location":"kt/coroutines/#channels","title":"Channels","text":"<p>Source</p> <p>Basically <code>BlockingQueue</code> but instead of a blocking <code>put</code>, it has a suspending <code>send</code> and instead of a blocking <code>take</code>, it has a suspending <code>receive</code>.</p> <pre><code>suspend fun produce(channel: Channel&lt;Int&gt;) {\n  repeat(20) {\n    delay(1000L)\n    channel.send(it)\n  }\n  channel.close()\n}\n\nsuspend fun consume(channel: Channel&lt;Int&gt;) {\n  for (i in channel) { // until channel is closed\n    println(\"${coroutineContext[CoroutineName]?.name} received $i\")\n  }\n}\n\nfun main() = runBlocking {\n  val channel = Channel&lt;Int&gt;()\n  launch(CoroutineName(\"A\")) { consume(channel) }\n  launch(CoroutineName(\"B\")) { consume(channel) }\n  launch(CoroutineName(\"C\")) { consume(channel) }\n  launch(CoroutineName(\"D\")) { consume(channel) }\n  launch(CoroutineName(\"P\")) { produce(channel) }\n  println()\n}\n</code></pre> <pre><code>A received 0\nB received 1\nC received 2\nD received 3\nA received 4\nB received 5\nC received 6\nD received 7\nA received 8\nB received 9\nC received 10\nD received 11\nA received 12\nB received 13\nC received 14\nD received 15\nA received 16\nB received 17\nC received 18\nD received 19\n</code></pre> <p>The example above had no buffer. Unbuffered channels transfer elements when sender and receiver meet each other (i.e. rendezvous). If sender is invoked first, then it gets suspended until receiver is invoked, and vice-versa.</p> <p>We can optionally specify as capacity <code>Channel&lt;T&gt;(42)</code> which allows sender to send multiple items before getting suspended.</p>"},{"location":"numbers/arithmetic/","title":"Bit arithmetic","text":""},{"location":"numbers/arithmetic/#rightmost-bits","title":"Rightmost bits","text":"<p><code>x &amp; (x-1)</code> to unset rightmost 1-bit in a word.</p> <pre><code>       x  = aaaa 1000\n     x-1  = aaaa 0111\nx &amp; (x-1) = aaaa 0000 \n</code></pre> <p><code>x</code> will have only one bit set if it's a power of two, meaning that <code>x &amp; (x-1) == 2</code> for \\(x = 2^n\\).</p> <p><code>x | (x+1)</code> to set rightmost 0-bit in a word. </p> <pre><code>       x  = aaaa 0111 \n     x+1  = aaaa 1000\nx | (x+1) = aaaa 1111 \n</code></pre> <p><code>x &amp; (x+1)</code> to unset trailing 1's in a word. </p> <pre><code>       x  = aaaa 0111\n     x+1  = aaaa 1000\nx &amp; (x+1) = aaaa 0000\n</code></pre> <p><code>x &amp; -x</code> to isolate rightmost 1-bit. </p> <pre><code>     x = 0000 1000  (8)\n    -x = 1111 1000 (-8)\nx &amp; -x = 0000 1000\n</code></pre> <p><code>x &lt;&lt; n | x &gt;&gt; (32-n)</code> to left shift <code>x</code> by <code>n</code> steps.</p> <p> 132nn3232&lt;&lt;n1&gt;&gt; (32-n)132</p> <p><code>x &gt;&gt; n | x &lt;&lt; (32-n)</code> to right shift <code>x</code> by <code>n</code> steps. </p> <p><code>x = a ^ b ^ x</code> to alternate between <code>a</code> and <code>b</code>, same as:</p> <pre><code>x == a ? b : a\n\na ^ b ^ a = b\na ^ b ^ b = a\n</code></pre>"},{"location":"numbers/representation/","title":"Number representation","text":"<p>A signed 32-bit integer can represent the range \\([-2^{31}, 2^{31}-1]\\). An unsigned integer need not allocate the sign bit and thus represents \\([0, 2^{32}-1]\\).</p>"},{"location":"numbers/representation/#2s-complement","title":"2's complement","text":"<p>(source)</p> <p>The method of representing signed integers on computers.</p> <ol> <li>A positive number \\(v\\) will have MSB as <code>0</code> and remaining \\(n-1\\) bits as \\(v\\).</li> <li>a negative number \\(v\\) will have MSB as <code>1</code> and remaining \\(n-1\\) bits as \\(\\overline{|v|} + 1\\). That is:<ol> <li>First take the binary representation of \\(|v|\\),</li> <li>then invert all its bits,</li> <li>and then add \\(1\\) while ignoring any overflow.</li> </ol> </li> </ol> <p>Example: 2's complement for 8-bit integer <pre><code>decimal          binary\n 0               0000 0000\n\n 1               0000 0001\n 2               0000 0010\n 3               0000 0011\n 4               0000 0100\n 5               0000 0101\n\n-1               1111 1111\n-2               1111 1110\n-3               1111 1101\n-4               1111 1100\n-5               1111 1011        \n</code></pre></p> <p>more examples</p>"},{"location":"numbers/representation/#convert-to-binary","title":"Convert to binary","text":"<p><code>%b</code> formatter is supported in most languages to get the number in binary format. However, for negative number it will simply print the binary representation of absolute value with <code>-</code> prefix. So we need a custom function:</p> <pre><code>// Can't declare method on int directly.\ntype Int int\n\nfunc (n Int) ToBinary(bits int) string {\n  // we know ahead of times how many runes we need\n  b := make([]rune, bits)\n\n  for i := 0; i &lt; bits; i++ {\n    if n &amp; (1 &lt;&lt; i) == 0 {\n      // MSB is at index 0, LSB is at index (length - 1)\n      b[bits - 1 - i] = '0'\n    } else {\n      b[bits - 1 - i] = '1'\n    }\n  }\n\n  return string(b)\n}\n\nfunc main() {\n  for _, v := range []Int{0, 1, 2, 3, 4, 5, -1, -2, -3, -4, -5} {\n    fmt.Printf(\"%2d as %s\\n\", v, v.ToBinary( /* should be strconv.IntSize */ 8))\n  }\n}\n</code></pre>"},{"location":"numbers/representation/#arithmetics","title":"Arithmetics","text":"Subtracting a positive numberAdding two positive numbersAdding two negative numbers <pre><code>15 - 9 = 15 + (-9)\n\n15 = 0000 1111\n-9 = 1111 0111\n 6 = 0000 0110\n</code></pre> <p>is same as adding a negative number</p> <pre><code>15 + 9\n\n15 = 0000 1111\n 9 = 0000 1001\n24 = 0001 1000\n</code></pre> <pre><code>-15 - 9\n\n-15 = 1111 0001\n -9 = 1111 0111\n-24 = 1110 1000\n</code></pre>"},{"location":"numbers/representation/#ieee-754","title":"IEEE 754","text":"<p>(source)</p> <p>a floating point is represented in 3 parts:</p> <p>\\[ \\text{number} = -1^{sign} \\cdot (1 + \\text{fraction}) \\cdot 2^{exponent}   \\]</p> <ol> <li>sign bit, as usual takes 1 bit (msb). <code>0</code> will result in \\(-1^0 = 1\\) and <code>1</code> will result in \\(-1^1 = -1\\).</li> <li>exponent takes 8 bits in single-precision float and 11 bits in double-precision floating point number.</li> <li>fraction takes the remaining 23 / 52 bits.</li> </ol> <p> signexponentfraction1-bit8/11-bits23/52-bits</p> single-precisiondouble-precision <ol> <li>If exponent \\( \\in [1, 254]\\), the number is in normalized form where the exponent has a bias / excess of \\(127\\) and range \\([-126, 127]\\). \\[\\text{number} = -1^{sign} \\cdot (1 + \\text{fraction}) \\cdot 2^{exponent \\color{red} - 127} \\]</li> <li>If exponent is \\(0\\), then number is de-normalized. Exponent has a very small fixed value of \\(2^{-126}\\) which is needed to represent very small numbers, including 0. \\[\\text{number} = -1^{sign} \\cdot (0 + \\text{fraction}) \\cdot 2^{- 126} \\]</li> <li>If exponent is \\(255\\), it represents special values of <code>NaN</code> and \\(\\pm\\infty\\).</li> </ol> <p>can represent integers without loss of precision in range \\([-2^{24}, 2^{24}]\\).</p> <ol> <li>If exponent \\( \\in [1, 2046]\\), the number is in normalized form where the exponent has a bias / excess of \\(1023\\) and range \\([-1022, 1023]\\). \\[\\text{number} = -1^{sign} \\cdot (1 + \\text{fraction}) \\cdot 2^{exponent \\color{red} - 1023} \\]</li> <li>If exponent is \\(0\\), then number is de-normalized. Exponent has a very small fixed value of \\(2^{-1022}\\) which is needed to represent very small numbers, including 0. \\[\\text{number} = -1^{sign} \\cdot (0 + \\text{fraction}) \\cdot 2^{- 1022} \\]</li> <li>If exponent is \\(2047\\), it represents special values of <code>NaN</code> and \\(\\pm\\infty\\).</li> </ol> <p>can represent integers without loss of precision in range \\([-2^{53}, 2^{53}]\\).</p>"},{"location":"partition/partition/","title":"Partitioning","text":""},{"location":"partition/partition/#two-way-partition","title":"Two-way partition","text":"pseudocodekotlintests <pre><code>parition(nums):\n  cursor = 0, pivot  = nums[0]\n\n  for i in [1, nums.size):\n    if nums[i] &lt; pivot:\n      swap(cursor++, i)\n\n  swap(0, cursor - 1)\n</code></pre> <pre><code>// returns the index of pivot\nfun MutableList&lt;Int&gt;.partitionTwoWay(pivotIndex: Int = 0): Int {\n  if (size &lt; 2) return size-1\n  if (pivotIndex != 0) swap(0, pivotIndex)\n\n  var cursor = 1; val pivot = this[0]\n\n  for (i in 1..&lt;size)\n    if (this[i] &lt; pivot)\n      swap(cursor++, i)\n\n  cursor-- // cursor was left in second half\n  swap(cursor, 0)\n  return cursor\n}\n\nfun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>package partition\n\nimport org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.streams.toList\n\nclass PartitionTest {\n\n  private lateinit var list: MutableList&lt;Int&gt;\n\n  @Test\n  fun testEmpty() {\n    list = mutableListOf()\n    list.partitionTwoWay()\n    assertEquals(listOf&lt;Int&gt;(), list)\n  }\n\n  @Test\n  fun testSingle() {\n    list = mutableListOf(9)\n    list.partitionTwoWay()\n    assertEquals(listOf(9), list)\n  }\n\n  @Test\n  fun testDouble() {\n    list = mutableListOf(1, 2)\n    list.partitionTwoWay()\n    assertEquals(listOf(1, 2), list)\n\n    list = mutableListOf(2, 1)\n    list.partitionTwoWay()\n    assertEquals(listOf(1, 2), list)\n  }\n\n  @Test\n  fun testTriple() {\n    list = mutableListOf(1, 2, 3)\n    list.partitionTwoWay(1)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(1, 3, 2)\n    list.partitionTwoWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 1, 3)\n    list.partitionTwoWay(0)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 3, 1)\n    list.partitionTwoWay(0)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 1, 2)\n    list.partitionTwoWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 2, 1)\n    list.partitionTwoWay(1)\n    assertEquals(listOf(1, 2, 3), list)\n  }\n\n  @Test\n  fun fuzzy() {\n    val nums = ThreadLocalRandom.current().ints(100, 0, 80).toList().toMutableList()\n    val copy = nums.stream().toList().toMutableList().sorted()\n\n    nums.sortByPartition()\n\n    assertEquals(copy, nums)\n  }\n\n  // basically quicksort\n  private fun MutableList&lt;Int&gt;.sortByPartition() {\n    if (size &lt; 2) return\n\n    val pivotIndex = partitionTwoWay()\n\n    val left = this.subList(0, pivotIndex).toMutableList()\n    val right = this.subList(pivotIndex + 1, size).toMutableList()\n\n    left.sortByPartition()\n    right.sortByPartition()\n\n    for (i in 0..&lt;left.size)\n      this[i] = left[i]\n    for (i in 0..&lt;right.size)\n      this[pivotIndex + i + 1] = right[i]\n  }\n}\n</code></pre> <p> ppat the start&lt; p&gt;= pbefore the final swapcursor0 1 ...p&lt; p&gt;= pafter the final swapcursor - 1</p> <p>We start the <code>cursor</code> at index <code>1</code>, moving all the elements \\(\\lt\\) <code>pivot</code> in the first partition.   At the end of the loop, <code>cursor</code> will be left pointing at the start of second partition, which contains elements \\(\\ge\\) <code>pivot</code>.   So we take a step back (<code>cursor--</code>) and move the pivot at the end of the first partition.</p>"},{"location":"partition/partition/#three-way-partition","title":"Three-way partition","text":"pseudocodekotlintests <pre><code>parition(nums, pivot):\n  l = 0, c = 0, r = nums.length - 1\n\n  while c &lt;= r:\n    switch(nums[c]):\n      &lt; pivot -&gt; swap(l++, c++)\n      = pivot -&gt; c++\n      &gt; pivot -&gt; swap(c, r--)\n\n  return (l, c)\n</code></pre> <pre><code>fun MutableList&lt;Int&gt;.partitionThreeWay(pivot: Int = this[0]): Pair&lt;Int, Int&gt; {\n  var l = 0; var c = 0; var r = size - 1\n  while (c &lt;= r)\n    when {\n      this[c]  &lt; pivot -&gt; swap(l++, c++)\n      this[c] == pivot -&gt; c++\n      this[c]  &gt; pivot -&gt; swap(c, r--)\n    }\n  return Pair(l, c)\n}\n\nfun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.streams.toList\n\nclass PartitionTest {\n\n  @Test\n  fun threeWaySimplest() {\n    var list = mutableListOf(1, 2, 3)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(1, 3, 2)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 1, 3)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(2, 3, 1)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 1, 2)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n\n    list = mutableListOf(3, 2, 1)\n    list.partitionThreeWay(2)\n    assertEquals(listOf(1, 2, 3), list)\n  }\n\n  @Test\n  fun fuzzyThreeWay() {\n    val list = ThreadLocalRandom.current().ints(100, 1, 4).toList().toMutableList()\n    val countOne = list.count { it == 1 }\n    val countTwo = list.count { it == 2 }\n    val countThree = list.count { it == 3 }\n    assertEquals(100, countOne + countTwo + countThree)\n\n    list.partitionThreeWay(2)\n\n    for (i in 0..&lt;countOne)\n      assertEquals(1, list[i])\n    for (i in countOne..&lt;countOne+countTwo)\n      assertEquals(2, list[i])\n    for (i in countOne+countTwo..&lt;countOne+countTwo+countThree)\n      assertEquals(3, list[i])\n  }\n}\n</code></pre> <p> = p&lt; p&gt; p0lc</p> <p>All elements \\(\\lt\\) <code>pivot</code> are in range \\([0, l)\\), elements \\(=\\) <code>pivot</code> are in range \\([l, c)\\),  and all elements \\(\\gt\\) <code>pivot</code> in \\([c, \\text{length})\\).</p>"},{"location":"search/binary/","title":"Binary Search","text":""},{"location":"search/binary/#tldr","title":"tl;dr","text":"<p>Finds an element in a sorted list. If not found, returns the place to insert said element.</p> pseudocodekotlintests <pre><code>search(array, needle):\n  l = 0, r = array.length - 1\n  while l &lt;= r:\n    m = (l + r) / 2\n\n    switch(needle):\n      &lt; array[m] =&gt; r = m - 1\n      = array[m] =&gt; return (m, found)\n      &gt; array[m] =&gt; l = m + 1\n\n  return (l, not found)\n</code></pre> <pre><code>fun &lt;T: Comparable&lt;T&gt;&gt; List&lt;T&gt;.binarySearch(needle: T): Pair&lt;Int, Boolean&gt; {\n  var l = 0; var r = size - 1;\n  while (l &lt;= r) {\n    val m = l + (r - l) / 2 // avoids overflow of (l+r)/2\n    when(needle.compareTo(this[m])) {\n      -1 -&gt; r = m - 1\n       0 -&gt; return Pair(m, true)\n       1 -&gt; l = m + 1\n    }\n  }\n  return Pair(l, false) // l and r have swapped boundary\n}\n</code></pre> <pre><code>package search\n\nimport org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport java.util.stream.IntStream\nimport kotlin.streams.toList\n\nclass BinarySearchTest {\n\n  @Test\n  fun searchEmpty() {\n    assertEquals(Pair(0, false), listOf&lt;Int&gt;().binarySearch(10))\n  }\n\n  @Test\n  fun searchOne() {\n    assertEquals(Pair(0, false), listOf(10).binarySearch(9))\n    assertEquals(Pair(0, true), listOf(10).binarySearch(10))\n    assertEquals(Pair(1, false), listOf(10).binarySearch(11))\n  }\n\n  @Test\n  fun searchTwo() {\n    assertEquals(Pair(0, false), listOf(8, 10).binarySearch(7))\n    assertEquals(Pair(0, true), listOf(8, 10).binarySearch(8))\n    assertEquals(Pair(1, false), listOf(8, 10).binarySearch(9))\n    assertEquals(Pair(1, true), listOf(8, 10).binarySearch(10))\n    assertEquals(Pair(2, false), listOf(8, 10).binarySearch(11))\n  }\n\n  @Test\n  fun fuzzySearchExistingKey() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val existingNeedle = list[ThreadLocalRandom.current().nextInt(100)]\n    val got = list.binarySearch(existingNeedle)\n\n    assertTrue(got.second)\n    assertEquals(existingNeedle, list[got.first])\n  }\n\n  @Test\n  fun fuzzySearchBeyondStart() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedle = list[0] - 1\n    val got = list.binarySearch(nonExistentNeedle)\n\n    assertFalse(got.second)\n    assertEquals(0, got.first)\n  }\n\n  @Test\n  fun fuzzySearchBeyondEnd() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedle = list[list.size - 1] + 1\n    val got = list.binarySearch(nonExistentNeedle)\n\n    assertFalse(got.second)\n    assertEquals(list.size, got.first)\n  }\n\n  @Test\n  fun fuzzySearchMissingInRange() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).sorted().toList().toMutableList()\n\n    val nonExistentNeedles = IntStream.range(0, 80).filter{ list.indexOf(it) &lt; 0 }.filter{ it &gt; list.first() &amp;&amp; it &lt; list.last() }.toList()\n    for (n in nonExistentNeedles) {\n      val got = list.binarySearch(n)\n\n      assertFalse(got.second)\n      assertTrue(list[got.first - 1] &lt; n)\n      assertTrue(n &lt; list[got.first])\n    }\n  }\n}\n</code></pre>"},{"location":"search/binary/#examples","title":"Examples","text":"<pre><code> 0  1  2  3  4  : Index\n[0, 2, 4, 6, 8] : Elements\n\ninsert -1 at 0\nfound   0 at 0\ninsert  1 at 1\nfound   2 at 1\ninsert  3 at 2\nfound   4 at 2\ninsert  5 at 3\nfound   6 at 3\ninsert  7 at 4\nfound   8 at 4\ninsert  9 at 5\ninsert 10 at 5\n</code></pre>"},{"location":"sort/mergesort/","title":"Mergesort","text":""},{"location":"sort/mergesort/#tldr","title":"tl;dr","text":"<p>Keep spliting the input in half and sort the halves recursively.</p> pseudocodekotlintests <pre><code>mergesort(array):\n  if array.length \u2264 2:\n    sort it normally\n    return\n\n  left  = array[0, length / 2)\n  right = array[length / 2, array.length)\n  mergesort(left)\n  mergesort(right)\n\n  array = merge(left, right) \n</code></pre> <pre><code>fun &lt;T: Comparable&lt;T&gt;&gt; MutableList&lt;T&gt;.mergesort(start: Int = 0, end: Int = size) {\n  val length = end - start\n  if (length &lt; 2) return\n  if (length == 2) {\n    if (this[start] &gt; this[start + 1]) swap(start, start+1)\n    return\n  }\n\n  val left = this // proxy for [start, start + length / 2)\n  val right = subList(start + length / 2, end).toMutableList()\n  left.mergesort(start, start + length / 2)\n  right.mergesort()\n\n  var l = start + length / 2 - 1; var r = right.size - 1; var c = end - 1\n  while (l &gt;= start &amp;&amp; r &gt;= 0) {\n    if (left[l] &gt; right[r]) this[c--] = left[l--]\n    else this[c--] = right[r--]\n  }\n  while (r &gt;= 0) this[c--] = right[r--]\n}\n\nprivate fun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.math.log2\nimport kotlin.streams.toList\n\nclass MergeSortTest {\n\n  @Test\n  fun empty() {\n    val list = mutableListOf&lt;Int&gt;()\n    list.mergesort()\n    assertEquals(listOf&lt;Int&gt;(), list)\n  }\n\n  @Test\n  fun single() {\n    val list = mutableListOf(6)\n    list.mergesort()\n    assertEquals(listOf(6), list)\n  }\n\n  @Test\n  fun double() {\n    var list = mutableListOf(2, 6)\n    list.mergesort()\n    assertEquals(listOf(2, 6), list)\n\n    list = mutableListOf(6, 2)\n    list.mergesort()\n    assertEquals(listOf(2, 6), list)\n  }\n\n  @Test\n  fun triple() {\n    var list = mutableListOf(2, 6, 10)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(2, 10, 6)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(6, 2, 10)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(6, 10, 2)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(10, 2, 6)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(10, 6, 2)\n    list.mergesort()\n    assertEquals(listOf(2, 6, 10), list)\n  }\n\n  @Test\n  fun fuzzy() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).toList().toMutableList()\n    val copy = list.toMutableList()\n    assertEquals(list, copy)\n    copy.sort()\n    assertNotEquals(list, copy)\n\n    list.quickSort()\n\n    assertEquals(list, copy)\n  }\n}\n</code></pre> <p>Half the struggle in mergesort is getting the boundaries right. A few points to highlight here:</p> <ol> <li>Splitting and merging should be done with \\([start, end)\\) as range and not \\([0, size)\\).</li> <li>We don't maintain an auxiliary arrary for the left half of the input. So when we recursively sort it, the correct range is \\([start, start + \\frac{end - start}{2})\\).</li> </ol>"},{"location":"sort/mergesort/#explanation","title":"Explanation","text":"<p> split array in two halvescopy the second half to an auxiliary arraysort the left half of original arraysort the auxiliary array1. Divide2. Conquer3. Combineleft-cursorright-cursorfill back in original</p> <p>First off, we don't need two auxiliary arrays in the divide step. Just one half is enough.Secondly, merge happens over the buffer area. In this case, it's the second half of the original array which is safely copied over in auxiliary array.Were we to copy left-to-right, elements from auxiliary array can overwrite left subarray's content before they can be merged correctly.</p>"},{"location":"sort/mergesort/#benchmark","title":"Benchmark","text":"benchmark code<pre><code>@Test\nfun benchmark() {\n  println(\"['input size','20n log(n)','library sort','homemade sort'],\")\n  for (n in listOf(100_000, 200_000, 300_000, 400_000, 500_000, 600_000, 700_000, 800_000, 900_000, 1_000_000)) {\n    val list = ThreadLocalRandom.current().ints(n.toLong(), 0, n / 2).toList().toMutableList()\n    val copy = list.toList().toMutableList()\n\n    var start = System.nanoTime()\n    list.mergesort()\n    val durationHomemade = System.nanoTime() - start\n\n    start = System.nanoTime()\n    copy.sort()\n    val durationLib = System.nanoTime() - start\n\n    val expected = 20 * n * log2(n.toFloat())\n\n    println(\"[$n,$expected,$durationLib,$durationHomemade],\")\n  }\n}\n</code></pre>"},{"location":"sort/quicksort/","title":"Quicksort","text":""},{"location":"sort/quicksort/#tldr","title":"tl;dr","text":"<p>We start with the partitioning as discussed previously and repeatedly partition the input in smaller and smaller chunks, implicitly sort them.</p> pseudocodekotlintests <pre><code>quicksort(array):\n  if (array.length &lt; 2) return\n\n  pivotIndex = partition(array)\n  quicksort(array[0, pivotIndex))\n  quicksort(array[pivotIndex, array.length))\n</code></pre> <pre><code>fun &lt;T: Comparable&lt;T&gt;&gt; MutableList&lt;T&gt;.quickSort(start: Int = 0, end: Int = size) {\n  // end is excluded, that's why length is not end - start + 1\n  if (end - start &lt; 2) return\n\n  val (ps, pe) = partition(start, end)\n  quickSort(start, ps)\n  quickSort(pe, end)\n}\n\nprivate fun &lt;T: Comparable&lt;T&gt;&gt; MutableList&lt;T&gt;.partition(start: Int, end: Int): Pair&lt;Int, Int&gt; {\n  var l = start; var c = start; var r = end - 1; val pivot = this[start]\n\n  while (c &lt;= r) {\n    when(this[c].compareTo(pivot)) {\n      -1 -&gt; swap(l++, c++)\n       0 -&gt; c++\n       1 -&gt; swap(c, r--)\n    }\n  }\n\n  return Pair(l, c)\n}\n\nprivate fun &lt;T&gt; MutableList&lt;T&gt;.swap(i: Int, j: Int) {\n  val t = this[i]\n  this[i] = this[j]\n  this[j] = t\n}\n</code></pre> <pre><code>import org.junit.jupiter.api.Assertions.*\nimport org.junit.jupiter.api.Test\nimport java.util.concurrent.ThreadLocalRandom\nimport kotlin.streams.toList\n\nclass QuickSortTest {\n\n  @Test\n  fun empty() {\n    val list = mutableListOf&lt;Int&gt;()\n    list.quickSort()\n    assertEquals(listOf&lt;Int&gt;(), list)\n  }\n\n  @Test\n  fun single() {\n    val list = mutableListOf(6)\n    list.quickSort()\n    assertEquals(listOf(6), list)\n  }\n\n  @Test\n  fun double() {\n    var list = mutableListOf(2, 6)\n    list.quickSort()\n    assertEquals(listOf(2, 6), list)\n\n    list = mutableListOf(6, 2)\n    list.quickSort()\n    assertEquals(listOf(2, 6), list)\n  }\n\n  @Test\n  fun triple() {\n    var list = mutableListOf(2, 6, 10)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(2, 10, 6)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(6, 2, 10)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(6, 10, 2)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(10, 2, 6)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n\n    list = mutableListOf(10, 6, 2)\n    list.quickSort()\n    assertEquals(listOf(2, 6, 10), list)\n  }\n\n  @Test\n  fun fuzzy() {\n    val list = ThreadLocalRandom.current().ints(100, 0, 80).toList().toMutableList()\n    val copy = list.toMutableList()\n    assertEquals(list, copy)\n    copy.sort()\n    assertNotEquals(list, copy)\n\n    list.quickSort()\n\n    assertEquals(list, copy)\n  }\n\n}\n</code></pre>"},{"location":"sort/quicksort/#benchmark","title":"Benchmark","text":"benchmark code<pre><code>@Test\nfun benchmark() {\n  println(\"['input size','20n log(n)','library sort','homemade sort'],\")\n  for (n in listOf(100_000, 200_000, 300_000, 400_000, 500_000, 600_000, 700_000, 800_000, 900_000, 1_000_000)) {\n    val list = ThreadLocalRandom.current().ints(n.toLong(), 0, n / 2).toList().toMutableList()\n    val copy = list.toList().toMutableList()\n\n    var start = System.nanoTime()\n    list.quickSort()\n    val durationHomemade = System.nanoTime() - start\n\n    start = System.nanoTime()\n    copy.sort()\n    val durationLib = System.nanoTime() - start\n\n    val expected = 20 * n * log2(n.toFloat())\n\n    println(\"[$n,$expected,$durationLib,$durationHomemade],\")\n  }\n}\n</code></pre>"}]}