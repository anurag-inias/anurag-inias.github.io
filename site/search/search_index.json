{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, H<sub>2</sub>O </p> <p>nec semper lorem quam in massa.</p>"},{"location":"#code-block","title":"Code block","text":"hello.kt<pre><code>fun main() { \n  println(\"Hello\")\n}\n</code></pre>"},{"location":"#latex","title":"LaTeX","text":"DisplayInline <p>\\[     x = \\frac{y}{z} \\]</p> <p>\\(a \\implies b\\)</p> <p>read more here</p>"},{"location":"#admonitions","title":"Admonitions","text":"<p>with some title</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. </p> and collapsible <p>Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>read more here</p>"},{"location":"#grid","title":"Grid","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. </p> <p>Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p> </p>"},{"location":"graph/about/","title":"About","text":"<p>A graph is a set of vertices \\(V\\) and a set of edges \\(E\\) connecting them.</p>"},{"location":"graph/about/#glossary","title":"Glossary","text":"<ol> <li>A simple graph is one such disallows parallel edges (multigraph) and self-loops.</li> <li>A path is a sequence of adjacent vertices. A simple path is one with distinct vertices and edges. </li> <li>A cycle is a simple path except for the first and last vertices being the same. A tour refers to a cyclic path which coveres every vertex.</li> <li>A subgraph is a subset of a graph's edges and/or vertices.</li> <li>Two graphs are isomorphic if relabelling one's vertices converts it into the other.</li> <li>A graph is connected if every vertex is reachable from every other. Otherwise it's made up of two or more connected components which are connected subgraphs themselves.</li> <li>A graph is complete if there is all vertices are adjacent. A complete subgraph is called a clique.</li> <li>A bipartite graph is one with vertices divided in two sets such that no edge connects vertices of same set.  123456</li> <li>An acyclic connected graph is called a tree. A spanning tree of a connected graph is a subgraph that contains all its vertices and is a tree.</li> <li>Given two vertices, a simple path connecting them that visits every vertex is called Hamilton path, and Euler path if it visits every edge.</li> <li>A directed acyclic graph (DAG) is a digraph with no directed cycles.</li> </ol>"},{"location":"graph/about/#properties","title":"Properties","text":"<ol> <li>A simple graph can edges numbering between \\(V-1\\) and \\(V (V-1) \\, /  \\, 2\\).</li> <li>Total number of different graphs with \\(V\\) vertices is \\(2^{V (V-1) \\, / \\, 2}\\).</li> <li>A graph is considered dense if \\(E \\propto V^2\\), so a graph with \\(O(V \\cdot log \\, V)\\) would be sparse.</li> <li>A graph has an Euler tour iff it is connected and all vertices are of even degree. Or exactly two of its vertices are of odd degree.</li> </ol>"},{"location":"graph/about/#implementation","title":"Implementation","text":"PlainWeighted <pre><code>class Graph {\n  // Use a [HashSet] instead to disallow parallel edges out of the box.\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Int&gt;&gt; = HashMap()\n\n  val vertices: List&lt;Int&gt;\n    get() = adjacency.keys.stream().toList()\n\n  fun neighbours(vertex: Int): List&lt;Int&gt; = adjacency[vertex] ?: listOf()\n\n  fun add(vararg vertices: Int) {\n    for (v in vertices)\n        adjacency.putIfAbsent(v, ArrayList())\n  }\n\n  fun connect(src: Int, dst: Int) {\n    add(src, dst)\n    if (src == dst) return   // disallow self-loops.\n\n    adjacency[src]?.add(dst)\n    adjacency[dst]?.add(src) // Remove this for directed graph.\n  }\n}\n\n// (Optional) Use a dedicated class to represent vertices.\ndata class Vertex(val label: String) {\n  constructor(label: Int) : this(label.toString())\n  override fun toString() = label\n}\n</code></pre> <pre><code>class Graph {\n  private val adjacency: MutableMap&lt;Int, MutableList&lt;Edge&gt;&gt; = HashMap()\n  ...\n}\n\ndata class Edge(val dst: Int, val weight: Int)\n</code></pre>"},{"location":"graph/breadth-first-search/","title":"Breadth-first Search","text":""},{"location":"graph/breadth-first-search/#about","title":"About","text":"<p>BFS explores the vertices of a graph in layers, each layer corresponding to increasing distance from the source. First layer discovers vertices neighbouring to the source, second layer discovers neighbours of the first layer and so on.</p> <p>It has a running time of \\(O(V+E)\\).</p>"},{"location":"graph/breadth-first-search/#implementation","title":"Implementation","text":"Pseudocode<pre><code>Q = stack.push(u)\nmark u as visited\nwhile Q is not empty:\n  v = Q.poll()\n  for each edge (v, w):\n    if w is not visted:\n      mark w as visited\n      Q.push(w)\n</code></pre> Kotlin<pre><code>fun bfs(graph: Graph, source: Vertex) {\n  val visited = HashSet&lt;Vertex&gt;()\n  val queue = ArrayList&lt;Vertex&gt;()\n\n  queue.add(source)\n  visited.add(source)\n\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    print(\"$u \")\n\n    for (v in graph.neighbours(u))\n      if (!visited.contains(v)) {\n        visited.add(v)\n        queue.add(v)\n      }\n  }\n}\n</code></pre> <p>Pay attention to the fact that we mark vertices <code>visited</code> before enqueuing them.</p>"},{"location":"graph/breadth-first-search/#properties","title":"Properties","text":"<ul> <li>BFS gives the shortest path in an unweighted graph, since in an unweighted graph, the shortest path is just the least number of hops.</li> <li>Consequently, it also gives the minimum spanning tree in an unweighted graph. Any spanning tree would be minimum spanning tree in an unweighted graph, so both BFS and DFS would work. </li> </ul>"},{"location":"graph/depth-first-search/","title":"Depth-first Search","text":""},{"location":"graph/depth-first-search/#about","title":"About","text":"<p>DFS is a linear time search and traversal algorithm, i.e. the runtime is \\(O(V+E)\\). In worst case it takes \\(O(V)\\) space to store the stack of vertices.</p>"},{"location":"graph/depth-first-search/#pseudocode","title":"Pseudocode","text":"DFS(u) recursive<pre><code>mark u as visited\nfor each edge (u, v):\n  if v is not visited:\n    DFS(v)\n</code></pre> DFS(u) iterative<pre><code>S = stack.push(u)\nwhile S is not empty:\n  v = S.pop()\n  if v is not visited:\n    mark v as visted\n    for each edge (v, w):\n      S.push(w)\n</code></pre> <p>Notice that in iterative approach, we push vertices on stack regardless of whether they are already visited. Rather, discovered status is checked post <code>pop</code>. </p> <p>If \\(a, b, c\\) are adjacent to \\(u\\), and the recursive DFS visits them in said order, then iterative implementation will visit them in reverse order of \\(c, b, a\\).</p>"},{"location":"graph/depth-first-search/#comparison-to-bfs","title":"Comparison to BFS","text":"BFS(u) iterative<pre><code>Q = stack.push(u)\nmark u as visited\nwhile Q is not empty:\n  v = Q.poll()\n\n\n  for each edge (v, w):\n    if w is not visted:\n      mark w as visited\n      Q.push(w)\n</code></pre> DFS(u) iterative<pre><code>S = stack.push(u)\n\nwhile S is not empty:\n  v = S.pop()\n  if v is not visited:\n    mark v as visted\n    for each edge (v, w):\n      S.push(w)\n</code></pre> <p>Why the iterative DFS postpone checking the <code>visited</code> status of a vertex? Why not check it before pushing it on stack? To understand this, consider the following graph:</p> <p> 0123</p> BFS like check<pre><code>push 1       stack = [1    ] # 1 visited\n\npop 1        stack = [     ]\npush 2 0 3   stack = [2 0 3] # 2 0 3 visited\n\npop 3        stack = [2 0  ]\npop 0        stack = [2    ]\npop 2        stack = [     ]\n\n\nTraversal: 1 3 0 2\n</code></pre> postpone visited check<pre><code>push 1       stack = [1      ]\n\npop 1        stack = [       ] # 1 visited\npush 2 0 3   stack = [2 0 3  ]\n\npop 3        stack = [2 0    ] # 3 visited\npush 2 1     stack = [2 0 2 1] \n\npop 1        stack = [2 0 2  ]\npop 2        stack = [2 0    ] # 2 visited\npush 3 1     stack = [2 0 3 1]\n\npop 1        stack = [2 0 3  ]\npop 3        stack = [2 0    ]\npop 0        stack = [2      ] # 0 visited\npush 1       stack = [2 1    ]\n\npop 1        stack = [2      ]\npop 2        stack = [       ]\n\n\nTraversal: 1 3 2 0\n</code></pre> <p>If we check the <code>visited</code> status before pushing vertices on stack, the algorithm will still work; in the sense that you'd not stuck in loops still. But, it wouldn't be a \"depth first\" search anymore.</p>"},{"location":"graph/depth-first-search/#enhancements","title":"Enhancements","text":"<p>We now consider the following enhancements on this simple version of DFS:</p> <ol> <li>Expand the concept of <code>visited</code>. <ul> <li>Consider a vertex <code>undiscovered</code> (WHITE) when it is not yet visited.</li> <li><code>discovered</code> (GRAY) when it is visted.</li> <li><code>explored</code> (BLACK) when its adjacency list has been examined.</li> </ul> </li> <li>Mark the time when a vertex is discovered as <code>pre</code> and when it's explored as <code>post</code>.</li> <li>If a vertex \\(v\\) is discovered following the edge \\((u, v)\\), mark \\(u\\) as \\(v\\)'s predecessor: \\(v_\\pi=u\\).</li> </ol> DFS(G)<pre><code>for u in G:\n  u.color = WHITE\n  u.\u03c0 = nil\n\ntime = 0\nfor u in G:\n  if u.color == WHITE:\n    DFS(G, u)\n</code></pre> DFS(G, u)<pre><code>u.pre = time++\nu.color = GRAY\n\nfor each (u, v) in G:\n  if v.color == WHITE:\n    v.\u03c0 = u\n    DFS(G, v)\n\nu.post = time++\nu.color = BLACK\n</code></pre> <p>Each <code>DFS(G, u)</code> call yields a depth-first tree \\(G_\\pi\\), a structural description of the traversal. \\(G_\\pi\\) is a subgraph of the original graph \\(G\\).</p> <ul> <li>In an undirected graph \\(G\\), an edge is called tree edge if it's present in \\(G_\\pi\\) too. Otherwise, it's a nontree edge. </li> <li>In a directed graph, you can also have:<ul> <li>Forward edge leading a vertex to its nonchild descendant in \\(G_\\pi\\).</li> <li>Back edge leading a vertex to its ancestor in \\(G_\\pi\\).</li> <li>Cross edge lead to neither descendant nor ancestor. Rather it's a node that's already explored (BLACK).</li> </ul> </li> </ul> <p> abcdforwardbackcross</p>"},{"location":"graph/depth-first-search/#properties","title":"Properties","text":"<p>For any given vertices \\(u\\) and \\(v\\), the ranges \\([u_{pre}, u_{post}]\\) and \\([v_{pre}, v_{post}]\\) either contain each other or are disjoint, but never interweaving. An edge \\((u, v)\\) is: </p> <ul> <li>Tree/Forward edge if \\( \\underset{u}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{v}{\\big]} \\; \\underset{u}{\\big]} \\).</li> <li>Back edge if \\( \\underset{v}{\\big[} \\; \\underset{u}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{v}{\\big]} \\).</li> <li>Cross edge if \\( \\underset{v}{\\big[} \\; \\underset{v}{\\big[} \\; \\underset{u}{\\big]} \\; \\underset{u}{\\big]} \\).</li> </ul> <p>Similarly, when a vertex \\(v\\) is first discovered following the edge \\((u, v)\\), then the edge can be distinguished based on \\(v\\)'s color:</p> <ul> <li>Tree edge if <code>v.color = WHITE</code>.</li> <li>Back edge if <code>v.color = GRAY</code>.</li> <li>Forward/Cross edge if <code>v.color = BLACK</code>.</li> </ul>"},{"location":"graph/depth-first-search/#recursive-implementation","title":"Recursive implementation","text":"<pre><code>fun recursive(\n  graph: Graph, source: Int, \n  colorMap: MutableMap&lt;Int, Color&gt; = HashMap(),\n  indent: Int = 0\n) {\n  colorMap[source] = Color.GRAY // vertex discovered\n\n  for (dst in graph.neighbours(source)) {\n    val dstColor = colorMap[dst] ?: Color.WHITE\n    val childIndent = report(source, dst, dstColor, indent) // verbose only\n    if (dstColor == Color.WHITE)\n      recursive(graph, dst, colorMap, childIndent)\n  }\n\n  colorMap[source] = Color.BLACK // vertex explored\n}\n\nprivate fun report(src: Int, dst: Int, dstColor: Color, indent: Int): Int {\n  val type = when (dstColor) {\n    Color.WHITE -&gt; \"tree\"\n    Color.GRAY -&gt; \"back\"\n    else -&gt; \"forward/cross\"\n  }\n  val row = \" \".repeat(indent) + \"$src-$dst\"\n  println(\"$row $type\")\n  return row.length - 1\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <p> 02617345</p> <pre><code>0-2 tree\n  2-0 back\n  2-6 tree\n    6-2 back\n    6-4 tree\n      4-6 back\n      4-5 tree\n        5-4 back\n        5-0 back\n        5-3 tree\n          3-4 back\n          3-5 back\n      4-7 tree\n        7-0 back\n        7-1 tree\n          1-7 back\n        7-4 back\n      4-3 forward/cross\n0-5 forward/cross\n0-7 forward/cross\n</code></pre>"},{"location":"graph/depth-first-search/#iterative-implementation","title":"Iterative implementation","text":"<p>Things are harder in iterative implementation.</p> incorrect implementation<pre><code>...\nv.color = GRAY # no-op\n\n\nif v is not visited:\n  mark v as visted\n  for each edge (v, w):\n    S.push(w)\n\n\n\n\nv.color = BLACK # overwrites GRAY\n</code></pre> correct implementation<pre><code>...\nv.color = GRAY\n\nexplored = true\nif v is not visited:\n  mark v as visted\n  for each edge (v, w):\n    S.push(w)\n    if w is WHITE:\n      explored = false\n\nif explored:\n  v.color = BLACK\n</code></pre> <p>In recursive implementation, vertices adjacent to \\(v\\) will see \\(v\\) as <code>GRAY</code> and thus see \\((v, u)\\) as back edge. But in iterative impelementation, they'd only ever encounter \\(v\\) as <code>BLACK</code> and mistake \\((v, u)\\) as forward/cross edge.</p> <p>To solve this, we mark a vertex <code>BLACK</code> only if the loop prior did not find any undiscovered neighbours.</p> <pre><code>fun iterative(graph: Graph, source: Int) {\n  val color = HashMap&lt;Int, Color&gt;()\n  val stack = ArrayDeque(listOf(Edge(source, source, 0)))\n\n  while (stack.isNotEmpty()) {\n    val (p: Int, u: Int, i: Int) = stack.removeFirst()\n    val c = color[u] ?: Color.WHITE\n    val ci = report(p, u, c, i)\n\n    if (c == Color.WHITE) {\n      color[u] = Color.GRAY\n\n      var explored = true\n      for (v in graph.neighbours(u)) {\n        val vc = color[v] ?: Color.WHITE\n        stack.addFirst(Edge(u, v, ci))\n        if (vc == Color.WHITE) \n          explored = false\n      }\n\n      if (explored)\n        color[u] = Color.BLACK\n    }\n  }\n}\n\ndata class Edge(var pred: Int, var vertex: Int, var indent: Int)\n\nprivate fun report(\n  src: Int, dst: Int, dstColor: Color, indent: Int\n): Int {\n  val type = when (dstColor) {\n    Color.WHITE -&gt; \"tree\"\n    Color.GRAY -&gt; \"back\"\n    else -&gt; \"forward/cross\"\n  }\n  val row = \" \".repeat(indent) + \"$src-$dst\"\n  println(\"$row $type\")\n  return row.length - 1\n}\n\nenum class Color { WHITE, GRAY, BLACK }\n</code></pre> <p> 02617345</p> <pre><code>0-0 tree\n  0-7 tree\n    7-4 tree\n      4-3 tree\n        3-5 tree\n          5-3 back\n          5-0 back\n          5-4 back\n        3-4 back\n      4-7 back\n      4-5 forward/cross\n      4-6 tree\n        6-4 back\n        6-2 tree\n          2-6 back\n          2-0 back\n    7-1 tree\n      1-7 back\n    7-0 back\n  0-5 forward/cross\n  0-2 forward/cross\n</code></pre>"},{"location":"graph/topological-sort/","title":"Topological Sort","text":""},{"location":"graph/topological-sort/#about","title":"About","text":"<p>Topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every edge \\((u, v)\\), \\(u\\) comes before \\(v\\) in the ordering.</p> <p>Such an ordering is only possible if there are no cycles in the graph, i.e. it's a DAG.</p>"},{"location":"graph/topological-sort/#example","title":"Example","text":"<p> 12345</p> Valid topological sortings<pre><code>1 2 3 4 5\n1 2 3 5 4\n</code></pre> <p> 134562</p> Valid topological sortings<pre><code>5 6 1 4 2 3\n6 5 4 2 3 1\n</code></pre>"},{"location":"graph/topological-sort/#dfs-based-algorithm","title":"DFS based algorithm","text":"<p>DFS will finish processing a vertex \\(u\\) before its predecessor \\(p\\), i.e. \\(p_{post} \\gt u_{post}\\). So laying out vertices in the descending order of \\(\\text{post}\\) time will give us their topological ordering. Additionally, if we keep track of each vertex's color, we can also detect cycles (i.e. edge to a <code>GRAY</code> neighbour) and know when topological ordering is not possible.</p> Pseudocode<pre><code>topologicalSort(G):\n  out = []\n  for u in G:\n    # If back-edge present, then TS not possible\n    if u is not visited:\n      DFS(G, u)\n  return out\n\nDFS(G, u):\n  mark u as visited\n  for each edge (u, v):\n    if v is not visited:\n      DFS(G, v)\n  out = [u, ...out]\n</code></pre> topologicalSort(G)<pre><code>fun topologicalSort(graph: Graph)\n  : List&lt;Vertex&gt; {\n  val out = ArrayList&lt;Vertex&gt;(\n    graph.vertices.size\n  )\n\n  val visited = HashSet&lt;Vertex&gt;()\n  fun dfs(source: Vertex) {\n    visited.add(source)\n    for (n in graph.neighbours(source))\n      if (!visited.contains(n))\n        dfs(n)\n    out.addFirst(source)\n  }\n\n  for (v in graph.vertices)\n    if (!visited.contains(v))\n      dfs(v)\n\n  return out\n}\n</code></pre>"},{"location":"graph/topological-sort/#kahns-algorithm","title":"Kahn's algorithm","text":"<p>The general idea behind this solution is that topological ordering will place source vertices before sink vertices. So we begin by listing all source vertices first (i.e. \\(\\text{in-degree} = 0\\)), followed by their neighbours, followed by their neighbour's neighbours and so on. </p> Pseudocode<pre><code>O = topological sort result = []\nQ = list of all vertices with in-degree = 0\n\nwhile Q is not empty:\n  u = Q.poll()\n  O += [u]\n\n  for (u, v) in G:\n    remove (u, v) from G\n    # discover neighbours of source vertices\n    v.indegree--\n    if v.indegree == 0:\n      Q.enqueue(v) \n\nif G has edges:\n  error \"graph has cycle(s)\"\nreturn O\n</code></pre> topologicalSort(G)<pre><code>fun topologicalSort(graph: Graph): List&lt;Vertex&gt; {\n  val out = ArrayList&lt;Vertex&gt;()\n\n  val indegree = graph.indegree()\n  val queue = indegree.filter { it.value == 0 }\n    .keys.toMutableList()\n  while (queue.isNotEmpty()) {\n    val u = queue.removeFirst()\n    out += u\n\n    for (v in graph.neighbours(u)) {\n      indegree[v] = indegree[v]!! - 1\n      if (indegree[v] == 0)\n        queue.add(v)\n    }\n  }\n\n  return out\n}\n\nfun Graph.indegree(): MutableMap&lt;Vertex, Int&gt; {\n  val indegree = HashMap&lt;Vertex, Int&gt;()\n  for (u in vertices) {\n    indegree.putIfAbsent(u, 0)\n    for (v in neighbours(u))\n      indegree[v] = 1+ indegree.getOrDefault(v, 0)\n  }\n  return indegree\n}\n</code></pre>"},{"location":"js/basics/","title":"Basics","text":""},{"location":"js/basics/#types","title":"Types","text":"number \\(\\&amp;\\) bigintstringbooleanundefined \\(\\&amp;\\) nullsymbolobject <p>Represents both integer and floating point numbers. </p> <pre><code>255 === 255.0 // true\n0xff          // same\n0b11111111    // same\n0.255e2       // same, decimal exponent notation\n</code></pre> <p>It uses double-precision 64bit number. \\(1\\) bit for sign, \\(11\\) bits for exponent and \\(52\\) bits for mantissa (a number b/w \\(0\\) and \\(1\\)).</p> <p>\\[   \\text{number} = -1^\\text{sign} \\cdot (1 + \\text{mantissa}) \\cdot 2^{\\text{exponent}} \\]</p> <p>There are also special numeric values <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code>.</p> <pre><code>1/0         // Infinity\n1/0 === 2/0 // true, Infinity/-Infinity are global variables\n\n// Represents computation error. It poisons mathematical expressions\n0/0         // NaN\nNaN == NaN  // false, no two NaN are same.\n</code></pre> <p>Integers can be represented without loss of precision in range \\([-2^{53}+1, 2^{53}-1]\\). Use <code>BigInt</code> beyond that.</p> <pre><code>Number.MAX_SAFE_INTEGER // 9007199254740991\nNumber.MAX_VALUE        // 1.7976931348623157e+308\n9007199254740991 + 1 === 9007199254740991 + 2 // true, 9007199254740992\n\nconst num = 1234567890123456789012345678901234567890n;\ntypeof num; // bigint\n</code></pre> <p>Don't mix <code>bigint</code> and <code>number</code> in expressions.</p> <p>Type coercion</p> <pre><code>Number(true)      // 1\nNumber(false)     // 0\nNumber(undefined) // NaN\n\nNumber(\"123\")     // 123\nNumber(\" 123\")    // 123, whitespace/line terminators are ignored\nNumber(\"0123\")    // 123, leading 0 is not taken as octal literal\nNumber(\"1,234\")   // NaN, separators are not supported\nNumber(\"   \")     // 0\nNumber(\"foo\")     // NaN\nNumber(\"false\")   // NaN\n\nNumber([])        // 0\nNumber([0])       // 0\nNumber([1])       // 1\nNumber([1, 1])    // NaN\n\nNumber({})        // NaN\n</code></pre> <p>Objects are first converted to primitive by calling <code>[@@toPrimitive]()</code>, <code>valueOf()</code>, and <code>toString()</code> in order; the resulting primitive is then converted to a number. </p> <p>Strings are sequences of UTF-16 code units in JS. Every code unit is 16bits long, and can represent most common characters like Latin, Greek, Cyrillic alphabets and many East Asian characters.</p> <pre><code>const s = \"A string\";\nconst s = 'A string';\nconst s = `A string`; // template literal\nconst s = new String(\"A string\"); // typeof = \"object\"\n\n\"cat\".charAt(1); // 'a', thre is no character type\n\"cat\"[1];        // 'a', not writable\n</code></pre> <p>JS distinguishes b/w <code>String</code> object and primitive string values (same for <code>Boolean</code> and <code>Number</code>).</p> <p>Type coercion</p> <pre><code>String(undefined) // 'undefined'\nString(null)      // 'null'\nString(0xff)      // '255', same as toString(10)\n</code></pre> <p>Type with only two values <code>true</code> and <code>false</code>.</p> <p>Both <code>null</code> and <code>undefined</code> are for the absence of value. <code>undefined</code> represents system-level, unexpected, or error-like absence of value. <code>null</code> on the other hand is for program-level, intentional absence of value.</p> <pre><code>null === undefined // false\nnull == undefined  // true\n\nnull === null      // true\n!null              // true\n</code></pre> <p>For legacy reasons <code>typeof(null)</code> is <code>object</code>, that's a language bug.</p> <p><code>undefined</code> a property of the global object. In all non-legacy browsers, it's a non-configurable, non-writable property. So avoid overriding it in legacy browsers.</p> <p>Built-in object whose constructor returns a <code>symbol</code> primitive, guaranteed to be unique. It is used to add unique property keys to an object that cannot collide with any other keys, so pretty useful for creating libraries.</p> <pre><code>const s = Symbol();\nSymbol(\"foo\") == Symbol(\"foo\"); // false\n\n// Prevents one from creating wrapper objects\nconst s = new Symbol(); // TypeError\n</code></pre> <p>To create shared symbols, use <code>Symbol.for</code>.</p> <pre><code>Symbol.for(\"foo\") // Symbol(foo)\nSymbol.for(\"foo\") == Symbol.for(\"foo\") // true\n\nconst s = Symbol.for(\"foo\");\nSymbol.keyFor(s); // 'foo'\n</code></pre> <p>All the aforementioned types are primitive, distinct from Object type. Read more about it here.</p>"},{"location":"js/basics/#typeof","title":"<code>typeof</code>","text":"<pre><code>typeof 0           // 'number'\ntypeof 1n          // 'bigint'\ntypeof true        // 'boolean'\ntypeof 'foo'       // 'string'\ntypeof undefined   // 'undefined'\ntypeof null        // 'object', known bug \ntypeof Symbol()    // 'symbol'\n\ntypeof {}          // 'object'\ntypeof console.log // 'function', still an object but treated differently by typeof\n</code></pre>"},{"location":"js/object/","title":"Object type","text":""},{"location":"js/object/#basics","title":"Basics","text":"<p>An object is a collection of properties and methods.</p> Object literal<pre><code>const person = {\n  name: \"Foo\",\n  age: 38,\n  about() {\n    console.log(`Hi! It's me, ${this.name}`);\n  }\n};\n\n// members can be added later too.\nperson.adios = function() { /* ... */ }\n</code></pre>"},{"location":"js/object/#prototypes","title":"Prototypes","text":"<p>Every object in JS has a built-in property called its prototype, which itself is an object, making a prototype chain until the very last ancestor with a <code>null</code> prototype. Most browser use <code>__proto__</code>, but it's recommended to use <code>Object.getPrototypeOf(person)</code>.</p> <p>When attempting to access a property/method on an object, JS will first look it up on the target object, followed by recursively looking for it on its prototype. The root prototype of all objects is <code>Object.prototype</code>.</p> <pre><code>// Not really blank. It'll be an object with default methods like \n// \"constructor\", \"isPrototypeOf\", valueOf, __defineGetter__, etc.\nObject.getPrototypeOf(person)                                         // {}\nObject.getPrototypeOf({}) === Object.getPrototypeOf(person)           // true\nObject.getPrototypeOf({}) === Object.getPrototypeOf(Object.prototype) // true \n\n// Prototype of a date instance for example: Date.prototype\nconst today = new Date();\nObject.getPrototypeOf(today)     // { toISOString: f, toUTCString: f, ... }\n</code></pre> <p>In JS, all functions have a property named <code>prototype</code>. When called as a constructor (i.e. with <code>new</code> operator), the constructed object inherits this property as its <code>prototype</code>.</p> <pre><code>function hello() {}\nhello.prototype // {}, a blank object as prototype to all constructed \"hello\"s.\nObject.getPrototypeOf(hello.prototype) === Object.prototype // true \n</code></pre> <p> todayDate.prototypeObject.prototypehello.prototype{}null</p>"},{"location":"js/object/#oop-classic-vs-js","title":"OOP: classic vs JS","text":"<p>Unlike typical OOP languages, classes and objects are not distinct constructs. Objects are often created w/o any separate class definition, either as just object literal or a constructor function.</p> <p>Constructor provide something like a class declaration to define the blueprint of the objects, and prototype allow implementing inheritance. </p> <p>In classic OOP languages, subclass instance is a singular object with methods from owne and parent classes. But in JS, it's essentially delegation. \"Subclass\" object doesn't actually have the method of \"superclass\", instead they reside in superclass's prototype.</p>"},{"location":"js/object/#constructor","title":"Constructor","text":"Class declaration using constructor<pre><code>function User(name) {\n  // this = {}; (implict)\n\n  this.name = name;\n  this.hi = function() {\n    console.log(`Hi, it's a me, ${this.name}`);\n  };\n\n  // return this; (implict)\n};\n\nconst bob = new User(\"Shepherd\");\n</code></pre>"},{"location":"js/object/#common-utils","title":"Common utils","text":""},{"location":"js/object/#objectassign","title":"<code>Object.assign</code>","text":"<p>Copy enumerable own properties from one or more source objects to a target object.</p> <pre><code>Object.assign(target, source1, source2, ...);\n\nconst source = { greet() { console.log(\"hi\"); } };\n\nObject.assign(Date.prototype, source); // Yes, we can do this!\n(new Date()).greet();                  // prints \"hi\"\n</code></pre>"},{"location":"js/object/#objecthasown","title":"<code>Object.hasOwn</code>","text":"<p>You can find native members of an object using two different ways:</p> <pre><code>Object.hasOwn(person, \"name\"); // true, recommended\nperson.hasOwnProperty(\"name\"); // true\n</code></pre> <p><code>hasOwn</code> is recommended because <code>hasOwnProperty</code> is not protected from being overridden.</p>"},{"location":"js/object/#sources","title":"Sources","text":"<ul> <li>MDN</li> </ul>"}]}